% http://www.regexplanet.com/advanced/python/index.html
% http://regexpal.com/
% can I link to these?
% Or should I make my own testing suite? not too difficult...
% Can I say "sublime text has them in ctl h alt r"?

% http://proquest.safaribooksonline.com.erl.lib.byu.edu/book/programming/regular-expressions/9781449327453/firstchapter#X2ludGVybmFsX0h0bWxWaWV3P3htbGlkPTk3ODE0NDkzMjc0NTMlMkZpZDIyMTEwNDcmcXVlcnk9


% regex? regular expressions? when to transition?

% Have each regular expressions next to a free-spaced one?

%%% TODO make a snippet that does this instead
%%% To auto-fill unfilled \regex tags
%%% find: ^%\s*\\regex\s+(\S+)\s+(.*)$(?!\s*\\begin\{lstlisting\})
%%% replace: $0\n\\begin{lstlisting}\n>>> pattern = re.compile(r"$1")\n>>> bool(pattern.match(""))\n% TODO\n$2\nTrue\nFalse\n\\end{lstlisting}
% $0
% \begin{lstlisting}
% >>> pattern = re.compile(r"$1")
% >>> bool(pattern.match(""))
% % TODO
% $2
% True
% False
% \end{lstlisting}
%%%



\lab{Algorithms}{Basic Regular Expressions}{Regular Expressions I}
\objective{Learn the basics using regular expressions to find patterns within strings}
\label{lab:Regex_I}

Regular expressions are a tool that allow for quick searching and replacing of general patterns of text.
While nearly all text editors have a find-and-replace feature which will find and replace literal strings of text, regular expressions are much more general; for example, using a single regular expression, you can find every email address in a text file without having to sift through it by hand.
% include email regex?
% TODO add a cool example here... this will do for now:
    % As an example, the following program will find and fill in missing colons after control statements in normally formatted python files: 
    % % ^((def|if|elif|else|while|for|with).*):\s*$

Now let's jump in with some examples!

\section*{Basics and Terminology}
A ``regular expression'' is simply a string of characters that has been formatted according to a certain syntax.
The strings ``^a*b\$'', ``hello world'', and ``[aeiou]{5,10}'' are all regular expressions, while the strings ``\\ not okay \\'', ``[x^3=?]'', and ``*{|}*'' are not regular expressions, for reasons we will see later.

We say that certain regular expressions or patterns ``match'' certain strings, according to the rules of regular expressions. The general idea is that a regular expression represents a large set of strings (for example, all valid email addresses), and if a specific string is in that set, we say that the expression matches that string.  

Regular expressions have been implemented in almost all languages, and many text editors actually have find-and-replace mode that use regular expressions. In each place you find regular expressions, unfortunately, the syntax may be slightly different. There is no definitive standard and no ``correct'' syntax for all regular expressions across all platforms. However, the orginal syntax and a few variants are very widespread, so basic regular expressions should be virtually the same in almost every situation you will encounter them.

The simplest use of regular expressions is to match text literally.
For example, the pattern ``cat'' matches the string ``cat'' but does not match the strings ``dog'' or ``bat''.

Now that we have a general idea of regular expressions and their syntax, we will see how to use them in Python.

\section*{Regular Expressions in Python}
The python package \li{re} is the python package used for regular expressions.
To use it, simply run the command \li{import re}.

The following code demonstrates using Python to verify what we said about the regular expression ``cat'':
\begin{lstlisting}
>>> bool(re.match(r"cat", "cat"))
True
>>> bool(re.match(r"cat", "dog"))
False
>>> bool(re.match(r"cat", "bat"))
False
\end{lstlisting}

The main functions we will use are \li{re.match(pattern, string)} which you can think of as returning a boolean variable for now, and \li{re.compile(pattern)} which returns a compiled Regular Expression object. You can then call \li{match(string)} on this compiled object, and it will also return a boolean.
Most programs always use the compiled form for efficiency, but the following two code snippets are equivalent:
\begin{lstlisting}
>>> pattern = re.compile("any regular expression")
>>> result = pattern.match("any string")
\end{lstlisting}
is equivalent to
\begin{lstlisting}
>>> result = re.match("any regular expression", "any string")
\end{lstlisting}

When coding a specific pattern, it is best to use Python's raw strings by prefacing the string with the `r' character.
We do this because the `\\' character is quite important in regular expressions; if we tried to use a `\\' character as part of a normal Python string, Python would think we were trying to escape a character. To get around this, we can either escape all backslahses in our regular expressions by replacing them with two backslashes each, or we can take the much easier route of using Python's raw strings.
To demonstrate this effect, suppose we wanted to know whether the regular expression ``\\Q[\\\\abc]\\[def\\\\]\\E'' matched the string ``xyz''. We could get our answer in either of the following ways:
\begin{lstlisting} % TODO check that this works!!! Three changing layers is freaking hard to think about
>>> bool(re.match("\\Q[\\\\abc]\\[def\\\\]\\E", "xyz"))
False
>>> bool(re.match(r"\Q[\\abc]\[def\\]\E", "xyz"))
False
\end{lstlisting}

Readability counts. We will be using Python's raw strings.  % TODO explain what raw strings are

\section*{Literal Characters and Metacharacters}
The following characters are used as metacharacters in regular expressions:
\begin{lstlisting}
. ^ $ * + ? { } [ ] \ | ( )
\end{lstlisting}

These characters mean special things when used in regular expressions, making the vast power of regular expressions possible.
We will get to their functions later. For now, what do we do if want to match these characters literally?
We simply escape these characters using the metacharacter `\\':
\begin{lstlisting}
>>> pattern = re.compile(r"\$2\.95 please")
>>> bool(pattern.match("$2.95 please"))
True
>>> bool(pattern.match("$295 please"))
False
>>> bool(pattern.match("$2.95"))
False
\end{lstlisting}


\begin{problem}
    Write a regular expression that uses literal characters and escaped metacharacters to match the following string: ``\{(~!@#\$\%^&*_+)\}.''
\end{problem}


A little misleadingly, the \li{re.match} method isn't actually checking whether the given regular expression matches entire strings.
Rather, it checks whether the regular expression matches \emph{at} the \emph{beginning} of the string, even if the string continues on afterward.
For example:
% \regex   x   x xabc abcx
\begin{lstlisting}
>>> pattern = re.compile(r"x")
>>> bool(pattern.match("x"))
True
>>> bool(pattern.match("xabc"))
True
>>> bool(pattern.match("abcx"))
False
\end{lstlisting}

You might not expect `x' to match with `xabc', but it does.
This can cause confusion and headache, so we'll have to be a little more precise with the help of metacharacters.

The \emph{line anchor} metacharacters, `^' and `\$', are used to match the start and the end of a line of text, respectively.
Let's see them in action:
% \regex   ^x$   x xabc abcx
\begin{lstlisting}
>>> pattern = re.compile(r"^x$")
>>> bool(pattern.match("x"))
True
>>> bool(pattern.match("xabc"))
False
>>> bool(pattern.match("abcx"))
False
\end{lstlisting}


% \begin{Warn}     % TODO should i include this?
%     From now until we say otherwise, we will be only using single-line regular expressions. At that point, certain things change slightly, and instead of confusing you with them now, we'll save those differnces until then.
% \end{Warn}


That's much better.

\begin{Tip}
Use line anchors (`^' and `\$') around your regular expressions to make sure the computer is actually doing what you want it to.
\end{Tip}

Let's move on to `(', `)', and `|'.
The `|' character matches one of two or more regular expressions:
\begin{lstlisting}
>>> pattern2 = re.compile(r"^red|blue$")
>>> pattern3 = re.compile(r"^red|blue|orange$")
>>> bool(pattern2.match("red")),     bool(pattern3.match("red"))
(True, True)
>>> bool(pattern2.match("blue")),    bool(pattern3.match("blue"))
(True, True)
>>> bool(pattern2.match("orange")),  bool(pattern3.match("orange"))
(False, True)
>>> bool(pattern2.match("redblue")), bool(pattern3.match("redblue"))
(False, False)
\end{lstlisting}

You can think of `|' as doing an ``or'' operation.
How would we create a regular expression that matched both ``one fish'' and ``two fish''?
Although the regular expression ``one fish|two fish'' works, there is a better way, by combining `|' with the `(' and `)' characters:
\begin{lstlisting}
>>> pattern = re.compile(r"(one|two) fish")
>>> bool(pattern.match("one fish"))
True
>>> bool(pattern.match("two fish"))
True
>>> bool(pattern.match("three fish"))
False
>>> bool(pattern.match("one two fish"))
False
\end{lstlisting}

The `(' and `)' characters are used to group sequences of characters together.
We will visit these again later.

For now, note that grouping characters doesn't intefere with how they get matched:
% \regex   r(hi)no(c(e)ro)s   rhinoceros
\begin{lstlisting}
>>> bool(re.match(r"r(hi)no(c(e)ro)s", rhinoceros"))
True
\end{lstlisting}

Note that the regular expression ``one|two fish'' would \emph{not} have matched ``one fish''. It would only match ``one'' and ``two fish''. The `|' metacharacter has the lowest precedence out of the metacharacters.


\begin{problem}
Write a regular expression that uses the `|' metacharacter to match the following six strings: % todo format; maybe give a shell prompt
    ``Book store'',
    ``Book supplier'',
    ``Mattress store'',
    ``Mattress supplier'',
    ``Grocery store'', and
    ``Grocery supplier''.
Note: Your regular expression should not match any other string, including strings such as ``Book store sale!''.
\end{problem}

\section*{Character Classes}
The `[' and `]' characters are used to create \emph{character classes}.
Here they are in action:
% \regex   b[aei]d   bad bed bid bud bod byd
\begin{lstlisting}
>>> pattern = re.compile(r"A[xy]A")
>>> bool(pattern.match("AxA"))
True
>>> bool(pattern.match("AyA"))
True
>>> bool(pattern.match("AzA"))
False
>>> bool(pattern.match("AAA"))
False
>>> bool(pattern.match("AxA: Why does this match? Were you paying attention?"))
True
\end{lstlisting}

In essence, a character class will match any one out of several characters.  

Inside character classes, we gain some new metacharacters:
\begin{lstlisting}
- ^ 
\end{lstlisting}

Although we've already seen `^' as a metacharacter, it has a different meaning when used inside of a character class.
When `^' appears \emph{as the first character} in a character classes, the character class matches everything not specified instead.
Think of `^' as performing a set complement on the character class.
For example:
% \regex   ^[^ab]$   c d _ # a b fish
\begin{lstlisting}
>>> pattern = re.compile(r"^[^ab]$")
>>> bool(pattern.match("c"))
True
>>> bool(pattern.match("d"))
True
>>> bool(pattern.match("#"))
True
>>> bool(pattern.match("a"))
False
>>> bool(pattern.match("b"))
False
>>> bool(pattern.match("fish"))
False
\end{lstlisting}

Note that the two `^' characters mean completely different things; the first one anchors us at the beginning of the line, while the second `^' performs a set complement on the character class `[ab]'.

The other character class metacharacter is `-'; this is used to specifiy a range of values.
For example:
% \regex   ^[a-z][0-9][0-9]$   a90 z73 A90 zs3
\begin{lstlisting}
>>> pattern = re.compile(r"^[a-z][0-9][0-9]$")
>>> bool(pattern.match("a90"))
True
>>> bool(pattern.match("z73"))
True
>>> bool(pattern.match("A90"))
False
>>> bool(pattern.match("zs3"))
False
\end{lstlisting}

Multiple ranges or characters can included in a single character class; in this case, the character class will match any character that fits either criterion:
\begin{lstlisting}
>>> pattern = re.compile(r"^[abcA-C][0-27-9]$")
>>> bool(pattern.match("b8"))
True
>>> bool(pattern.match("B2"))
True
>>> bool(pattern.match("a9"))
True
>>> bool(pattern.match("a4"))
False
>>> bool(pattern.match("E1"))
False
\end{lstlisting}

Finally, there are some built-in shorthands for certain character classes: 
\begin{description}
    \item[`\\d'] matches any digit; it is equivalent to `[0-9]'
    \item[`\\w'] (think ``word'') matches any alphanumeric character or underscore; it is equivalent to `[a-zA-Z0-9_]'
    \item[`\\s'] (think ``space'') matches any whitespace character; it is equivalent to `[ \\t\\n\\r\\f\\v]'
\end{description}
The following character classes are the complements of those above:
\begin{description}
    \item[`\\D'] is equivalent to `[^0-9]' and `[^\\d]'
    \item[`\\W'] is equivalent to `[^a-zA-Z0-9_]' and `[^\\w]'
    \item[`\\S'] is equivalent to `[^ \\t\\n\\r\\f\\v]' and `[^\\s]'
\end{description}

These character classes can be used in character classes; for example, `[\\s_A-Z]' will match an underscore, any capital letter, or any whitespace character.

The `.' metacharacter, equivalent to `[^\\n]' on UNIX and `[^\\r\\n]' on Windows, matches any character besides a new line character.
For example:
% \regex   ^.\d.$   a0b 888 n2% abc m&m cat
\begin{lstlisting}
>>> pattern = re.compile(r"^.\d.$")
>>> bool(pattern.match("a0b"))
True
>>> bool(pattern.match("888"))
True
>>> bool(pattern.match("n2%"))
True
>>> bool(pattern.match("abc"))
False
>>> bool(pattern.match("m&m"))
False
>>> bool(pattern.match("cat"))
False
\end{lstlisting}

\begin{problem}
Write a regular expression that matches only the following strings: % todo format
    `a',
    `b',
    `c',
    `x',
    `y', and
    `z'
Your regular expression should include line anchors and \emph{should only be 8 characters long}.
(For example, the regular expression ``^hi!\$'' is 5 characters long and ``^[\d\s]\$'' is 8 characters long)
\end{problem}

\begin{problem}
A valid python identifier is defined to be a string composed of any alphabetic character or underscore, followed by any number of alphanumeric characters or underscores.

Write a regular expression that matches any valid python identifier that has exactly five characters.
For example, your regular expression should match each of the following: % todo format
    `mouse',
    `HORSE',
    `_1234', and
    `__x__'
but none of the following: % todo format
    `3rats',
    `err*r',
    `sq(x)', and
    `fishing'.

Hint: Use the `\w' character class to keep your regular expression relatively short.
\end{problem}

\section*{Repetition}
The `*', `+', `\{', and `\}' metacharacters are used for repetition, making them very powerful.
The `*' metacharacter means ``Match zero or more times (as many as possible)'' when it follows another regular expression.
For instance:
% \regex   ^a*b$   b ab aab aaab abab abc
\begin{lstlisting}
>>> pattern = re.compile(r"^a*b$")
>>> bool(pattern.match("b"))
True
>>> bool(pattern.match("ab"))
True
>>> bool(pattern.match("aab"))
True
>>> bool(pattern.match("aaab"))
True
>>> bool(pattern.match("abab"))
False
>>> bool(pattern.match("abc"))
False
\end{lstlisting}

The `+' metacharacter means ``Match one or more times (as many as possible)'' when it follows another regular expression.
As an example:
% \regex   ^h[ia]+$   ha hii hiai haaia h hah he
\begin{lstlisting}
>>> pattern = re.compile(r"^h[ia]+$")
>>> bool(pattern.match("ha"))
True
>>> bool(pattern.match("hii"))
True
>>> bool(pattern.match("hiaiaa"))
True
>>> bool(pattern.match("h"))
False
>>> bool(pattern.match("hah"))
False
\end{lstlisting}

It's important to understand why ``hiaiaa'' \emph{is} a match here; matching multiple times means matching the preceeding expression multiple times, not matching the preceeding expression once and then matching that same afterwards. % Todo clarify this

The `?' metacharacter means ``Match one time (if possible) or do nothing'' when it follows another regular expression:
% \regex   ^abc?$   abc ab abd ac
\begin{lstlisting}
>>> pattern = re.compile(r"^abc?$")
>>> bool(pattern.match("abc"))
True
>>> bool(pattern.match("ab"))
True
>>> bool(pattern.match("abd"))
False
>>> bool(pattern.match("ac"))
False
\end{lstlisting}

More generally, the curly brace metacharacters are used to specify a specific range of repetition:
% \regex   ^a{2,4}$   a aa aaa aaaa aaaaa aaaaaa bbb
\begin{lstlisting}
>>> pattern = re.compile(r"^a{2,4}$")
>>> bool(pattern.match("a"))
False
>>> bool(pattern.match("aa"))
True
>>> bool(pattern.match("aaa"))
True
>>> bool(pattern.match("aaaa"))
True
>>> bool(pattern.match("aaaaa"))
False
\end{lstlisting}

If two arguments \li{x} and \li{y} are given, the preceeding regular expression must appear between \li{x} and \li{y} times, inclusive, in order for the overall expression to match.

\begin{Warn}
In this last example, line anchors can save us from a lot of confusion. Note the differences between the following example and the example immediately above:
% \regex   a{2,4}   a aa aaa aaaa aaaaa aaaaaa
\begin{lstlisting}
>>> pattern = re.compile(r"a{2,4}")
>>> bool(pattern.match("a"))
False
>>> bool(pattern.match("aa"))
True
>>> bool(pattern.match("aaa"))
True
>>> bool(pattern.match("aaaa"))
True
>>> bool(pattern.match("aaaaa"))
True
\end{lstlisting}
\end{Warn}

If only one argument \li{x} is given followed by a comma, then there must be \li{x} or more instances of the preceeding regular expression. If only one argument \li{x} is given with no comma, there must be \emph{exactly} \li{x} instances of the preceeding regular expression:
\begin{lstlisting}
>>> exactly_three = re.compile(r"^a{3}$")
>>> three_or_more = re.compile(r"^a{3,}$")
>>> bool(exactly_three.match("a")), bool(three_or_more.match("a"))
(False, False)
>>> bool(exactly_three.match("aa")), bool(three_or_more.match("a"))
(False, False)
>>> bool(exactly_three.match("aaa")), bool(three_or_more.match("aaa"))
(True, True)
>>> bool(exactly_three.match("aaaa")), bool(three_or_more.match("aaaa"))
(False, True)
>>> bool(exactly_three.match("aaaaa")), bool(three_or_more.match("aaaaa"))
(False, True)
\end{lstlisting}



% TODO Greedy and Lazy Repetition
% maybe after these problems?


\begin{problem}
Write a regular expression that matches any valid python function call where the function name is a valid python identifier and the function has no arguments.
For example, your regular expression should match each of the following: % todo format
    compile(),
    __unicode__(), and
    a113()
and should not match any of the following:
    pattern.match(),
    fxn(no_arguments_please),
    365_day_timer(),
    variable,
    err*r(), and
    sleep()()
\end{problem}

\begin{problem}
Write a regular expression that matches any valid python function call where the function name is a valid python identifier and the function has any number of variables as arguments, all of which are valid python identifiers.
For example, your regular expression should match each of the following: % todo format
    compile(pattern,string)
    sleep()
    a113(_throwaway_variable,   camelCaseIsOkayToo)
and should not match any of the following:
    do_problem(error, ),
    variable,
    not.allowed(args),
    err*r(gamma),
    sleep("hello"),
    sum(*my_list), and
    func(value=my_constant)
\end{problem}


    % TODO working here


% % % LAB OUTLINE:
% TODO Intro to why
% TODO 1~2 Examples to show what the main idea is
% TODO     One in general regex
% TODO     Then repeat it in specifically a python format
% TODO Using regex in python
    % regex_bulk.py
        % Shoot this may be bad for them.... ughhhh
        % At the very least talk about how spaces work perfectly fine, we're just saving space
    % Talk about raw strings
    % tell them we've assumed single line regexs for now?
    % Warn about other flavors (here?)
% Literal matching
% Special characters
%     Escaping
%         ("and this why we need raw strings! lol")
% Line Anchors (^, $)
% OR-ing (|), Character classes ([]), shorthands (\w)
% Dot
%     almost all (no line breaks)
%     Careful, can be expensive to use
% Repetition (*, +, {,})
%     Maybe add warning about ReDoS? Not really too important
%     Greedy v. Lazy


% Maybe split lab here?


% Groups/Capturing
%     Non capturing groups
%     replace fxnality
%         re.sub
%     named groups
% Backreferences
% Anchors (\b, explain ^ and $ more)
% 4 types of Lookaround
    % talk about whether it's supported in every

% Summary Table at end of first lab, 2 at end of 2nd lab 
