\lab{Algorithms}{Simplex Method}{Simplex Method}
\objective{Write your own Simplex solver that can solve standard maximization linear programs.}
\label{lab:Simplex}

The Simplex Algorithm is one of the most notable algorithms invented in the last 100 years.
It is a very straight-forward algorithm for finding optimal solutions to convex problems.
The algorithm finds the optimal solution by traversing the edges of the feasible region of the system.

\section{Standard Form}
The Simplex Algorithm accepts a linear program in standard form.
A linear program can always be expressed in linear form.
If a linear program is of the following format, it is said to be in standard form.
\begin{align*}
\text{maximize}\qquad & c^T x \\
\text{subject to}\qquad & A x \leq b \\
 & x \geq 0
\end{align*}

Such a linear program defines a region in space called the feasible region.
All points in this feasible region satisfy all the constraints.
The Simplex algorithm moves along the vertices of the feasible region searching for an optimal point.
It does this by moving along the edges of the feasible region in such a way that the objective function is always increased.

To write a Simplex solver is largely straight forward.
We write a function to perform each step of the Simplex algorithm.
To become familiar with the execution of the Simplex algorithm, it is helpful to work several examples by hand.

\section*{The Simplex Solver}
Our program will be more lengthy than many other lab exercises and will consist of a collection of functions working together to produce a final result.
It is important to clearly define the task of each function and how all the functions will work together.
If this program is written haphazardly, it will be much longer and harder to read than it needs to be.
We will walk you through the steps of implementation as a Python class.
Since the Simplex algorithm assumes that all the variables are non-negative, we do not need any special logic for it.

For demonstration purposes, we will use the following linear program.
\begin{align*}
\text{maximize}\qquad & 3x_1 + 2x_2 \\
\text{subject to}\qquad 
& x_1 - x_2 \leq 2 \\
& 3x_1 + x_2 \leq 5 \\
& 4x_1 + 3x_2 \leq 7 \\
& x_1, x_2 \geq 0.
\end{align*}

\subsection{Accepting a Linear Program}
The first task that we must perform determining if we can even use the Simplex algorithm.
To do this, we assume that the linear program is presented to us in standard form.
We need to check that this linear program is even feasible (has a feasible region).

\begin{problem}
Write a Python class that will accept a linear program and check its feasibility.
You may implement the feasibility check directly into the class initialization method, or use a separate class method.
To simplify the implementation of your solver, we only check feasibility at the origin.
If the linear program is unfeasible at the origin, alert the user that Simplex might not work as expected.
Your class might have the following structure, where the linear program is accepted in the initialization method.
\begin{lstlisting}
class SimplexSolver(object):
    def __init__(self, c, A, b):
        if infeasible:
            print "LP is infeasible"
\end{lstlisting}
\label{prob:initsolver}
\end{problem}

\subsection{Adding Slack Variables}
When adding slack variables, it is useful represent all of your variables in a convenient way.
One effective way is to refer to a variable by its subscript.  
We would use the integer 0 to refer to the variable $x_0$, the integer 1 to refer to $x_1$, and so on.
There should be some way to track which variables are basic and which variables are non-basic.
A useful representation for the variables is a Python list, where the elements of the list are integers.
Since we know how many basic variables we have, we can partition the list so that all the basic variables are kept in the first $n$ locations, and all the non-basic variables are stored at the end of the list.
Swapping two elements of list can be done in a single, efficient line of Python code
\begin{lstlisting}
L = [0, 1, 2, 3, 4]
L[1], L[3] = L[3], L[1]
\end{lstlisting}

\begin{problem}
For your solver, design and implement a way to store and track all of the basic and non-basic variables.

\emph{Hint: Using integers that represent the index of each variable is useful for Problem \ref{prob:blands}.}
\label{prob:slackvars}
\end{problem}

\subsection{Creating a Tableau}
After we have determined that our program is feasible, we need to create the tableau that will be used in the Simplex algorithm.
You may structure the tableau to suit your specific implementation.
Remember that your Tableau will need to include in some way the slack variables that you created in Problem \ref{prob:slackvars}.

There are many different ways to build your tableau.
One way is to mimic the tableau that likely be used when solving Simplex problems by hand.
This is a very simple easy to build tableau.
\begin{equation}
T = \begin{bmatrix}
    0 & -c^T & 1  \\
    b & A 
    \end{bmatrix}
\label{eqn:hand_tab}
\end{equation}
For our example problem, the initial tableau would look
\begin{equation*}
T = \begin{bmatrix}
    0 & 4 & 2 & 1 \\
    5 & -1 & 0 & 0 \\
    25 & -4 & -1 & 0 \\
    125 & -8 & -4 & -1
    \end{bmatrix}
\end{equation*}

The advantage of using this kind of tableau is that it is easy to check your program by hand.
The disadvantage is that pivot operations require careful bookkeeping to track the variables and constraints.

We can also use a tableau of the following format (such that $T$ is a square matrix of size $s \times s$ 
where $s$ is the sum of the number of variables and the number of constraints plus 1).
\begin{equation}
T = \begin{bmatrix}
    0 & c^T   & 0 & \cdots & 0 \\
    0 & I_n & \boldsymbol{0} & \cdots & \boldsymbol{0} \\
    b & -A  & \boldsymbol{0} & \cdots & \boldsymbol{0}
\end{bmatrix}
\label{eqn:matrix_tab}
\end{equation}
The advantage of this form of tableau is all the pivot bookkeeping is built into the matrix.
For our example problem, the initial tableau of this form would look
\begin{equation*}
T = \begin{bmatrix}
        0 & 3 & 2 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 & 0 \\
        2 &-1 & 1 & 0 & 0 & 0 \\
        5 &-3 &-1 & 0 & 0 & 0 \\
        7 &-4 &-3 & 0 & 0 & 0
\end{bmatrix}
\end{equation*}

\begin{problem}
Add a method to your Simplex solver that will create the tableau that you will use.
Using a NumPy array to represent your tableau will simplify several parts of the Simplex algorithm
Your class may have the following structure at this point
\begin{lstlisting}
class SimplexSolver(object):
    def __init__(self, c, A, b):
        if infeasible:
            print "LP is infeasible"
            
        self.makeTableau()
        
    def makeTableau(self):
        pass
\end{lstlisting}
\label{prob:maketableau}
\end{problem}

\subsection{Pivoting}
Pivoting is the mechanism that really makes Simplex useful.
The method of pivoting swaps basic and nonbasic variables.
Depending on how you store your variables, you may need to modify different a few different parts of your solver to reflect this swapping.
When initiating a pivot, you need to determine what variables will be swapped.
To calculate binding 

In the tableau representation, you find a specific element to pivot on and the row and column that contain that pivot element are the variables that need to be swapped.

Gaussian elimination is used to reduce the constraints so that the columns we just used in pivoting is the an elementary vector.


If we are using the tableau representation in equation \ref{eqn:matrix_tab}, pivot operations are reduced to a simple matrix equation:
\[T = T + T_m \otimes T_n,\]
where $T_m$ is the column corresponding to the variable entering the basis and $T_n$ is a normalized vector corresponding to the variable leaving the basis.  The result of the equation is the new tableau.


\begin{problem}
Write a method that will determine the pivot row and pivot column according to Bland's Rule.
\begin{definition}[Bland's Rule]
Choose the nonbasic variable with the smallest index that has a positive coefficient in the objective function
as the leaving variable.  Choose the basic variable with the smallest index among all the binding basic variables.
\end{definition}

Bland's Rule is important in avoiding cycles when performing pivots.
This rule guarantees that a feasible Simplex problem will terminate in a finite number of pivots.
\label{prob:blands}
\end{problem}

\begin{problem}
Add methods that your Simplex solver that will perform a single pivot operation from start to completion.
You pivoting method should check for unboundedness.  
If during pivoting, the system becomes unbounded, return an exception to the user.
\end{problem}

\subsection{Reading the Tableau}
When your solver has reached a maximal point, it would be nice if the user doesn't have to extract the maximal solution from the tableau.

\begin{problem}
Write an additional method in your solver that will return the maximal solution in the format: \li{(max value, basic variables, nonbasic variables)}, where the basic and nonbasic variables are represented as two dictionaries that map the subscript of the variable to its corresponding value.
For example, the tuple \li{(55.0, \{0: .5, 3: .33333\}, \{1: 0, 2: 0\})} represents the solution to the system 
where maximal value of the objective function is $55.0$ and the 
basic variables are $x_0=.5$ and $x_3=.33333$ and the nonbasic variables are $x_1, x_2$ which are both zero.
The correct format of this tuple is critical as this tuple of information will be used judge if your solver works!
\end{problem}






%-------------------------------------------------------
where $c \in \mathbb{R}^n$ is a column vector, $b \in \mathbb{R}^m$ is a row vector, and $A \in \mathbb{R}^{m \times n}$.
The output $x$ is the optimal point and the optimal value is {\tt fval}.
The output {\tt exit} is one of the following values:
\begin{itemize}
\item 1: Successful execution--you found a solution.
\item 2: The problem is infeasible.
\item 3: The problem is unbounded.
\end{itemize}
If either of the two error events occur, you should return \li{None} for the values of \li{x} and \li{fval}.

You are free to implement {\tt linprog} any way you see fit, provided it satisfies the above requirements (you cannot just call an existing lp solver however, and you must use the Simplex method!).

\section*{Tableau Representation}

The first problem you need to address is how to represent the tableau.
We're going to use an approach that might be a little confusing at first but greatly simplifies the pivot operations.
We recommend creating an $m + n + 1$ square NumPy matrix, where $m$ is the number of constraints and $n$ is the number of decision variables.
The first row represents the objective function and the first column is for the constants.
The remaining columns are the coefficients of the variables.
The remaining rows express the value of the variables in terms of a constant and the nonbasic variables.
To illustrate this approach, let's consider the following example problem:

\begin{align*}
	\mbox{maximize}\qquad
        &    3x_1 + 2x_2 \\
	\mbox{subject to}\qquad
        &     x_1 - x_2 \leq 2 \\
		&	 3x_1 + x_2 \leq 5 \\
		&	 4x_1 + 3x_2 \leq 7 \\
		&     x_1, x_2 \geq 0.
\end{align*}

There is no need to distinguish the slack variables from the decision variables, so we will call our slack variables $x_3, x_4,$ and $x_5$.
Then our problem becomes
\begin{align*}
	\mbox{maximize}\qquad
        &    3x_1 + 2x_2 \\
	\mbox{subject to}\qquad
        &     x_1 - x_2 + x_3 = 2 \\
		&	 3x_1 + x_2 + x_4 = 5 \\
		&	 4x_1 + 3x_2 + x_5 = 7 \\
		&     x_1, x_2, x_3, x_4, x_5 \geq 0.
\end{align*}

We initialize simplex by making the decision variables $x_1, x_2$ nonbasic and the slack variables basic (assuming the origin is feasible, but we will deal with initially infeasible problems shortly).
The objective function is already written in terms of the nonbasic variables: $\zeta = 0 + 3x_1 + 2x_2$.
We want to write all the variables in terms of the nonbasic variables. This information we get from the constraints:
\[ x_3 = 2 - x_1 + x_2, \qquad x_4 = 5 - 3x_1 - x_2, \qquad x_5 = 7 - 4x_1 - 3x_2. \]
For consistency, and simplicity that will be demonstrated later on, we want to express ALL the variables in terms of the nonbasic variables, not just the basic variables, so we add the expressions
\[ x_1 = x_1, \qquad x_2 = x_2 \]
to the tableau.
This may seem silly, but it makes pivot operations very simple, as we will see.
In matrix form, we then have the following initial tableau.

\[
	T = \begin{bmatrix}
		0 & 3 & 2 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 & 0 & 0 \\
		0 & 0 & 1 & 0 & 0 & 0 \\
		2 &-1 & 1 & 0 & 0 & 0 \\
		5 &-3 &-1 & 0 & 0 & 0 \\
		7 &-4 &-3 & 0 & 0 & 0
	\end{bmatrix}.
\]
The first row is the objective function written as a constant plus a linear combination of the nonbasic variables.
The remaining rows are all the variables written as a constant plus a linear combination of the nonbasic variables.
The general form of the $T$ matrix is
\[ T = \begin{bmatrix}
    0 & c^T   & 0 \\
    0 & I_n & 0 \\
    b & -A  & 0
\end{bmatrix}, \]
where $I_n$ is an $n \times n$ identity matrix.
Therefore, your {\tt createtableau} function might include code like the following

\begin{lstlisting}
>>> m,n = A.shape
>>> s = m + n + 1;    % number of variables + number of constraints + 1
>>> T = numpy.zeros((s,s))
>>> T[0, 1:n+1] = c.T
>>> T[s-n-1:s, 0] = b.squeeze()
...
\end{lstlisting}

Note that you need the squeeze function, built into numpy, to remove single-dimensional entries from the shape of a numpy array. 

\section*{Pivot Operations}

One of the nice features of the proposed tableau representation is the simplicity of pivot operations.
In our example problem, the first pivot should occur with $x_1$ leaving and $x_4$ entering.
In other words, we want to pivot at row $i = 4$ and column $j = 1$ in the tableau (the indices are offset by one because of the objective function and the row of constants).
The row corresponding to $x_4$ is
\[
\begin{bmatrix} 5 &-3 &-1 & 0 & 0 & 0\end{bmatrix}.
\]
This represents the equation
\[
	x_4 = 5 - 3x_1 - x_2.
\]
Our eventual goal is to solve for $x_1$ and substitute into the remaining rows of the tableau.
A simple method to accomplish this is to rewrite the equation so that we have zero on the left-hand side:
\[
	0 = 5 - 3x_1 - x_2 - x_4.
\]
Now, we can normalize this equation so that the coefficient of $x_1$ is -1.
This is always accomplished by dividing the equation by the negative of the coefficient of $x_1$:
\begin{equation}\label{eq:zero-equation}
	0 = \frac{5}{3} - x_1 - \frac{1}{3}x_2 - \frac{1}{3}x_4.
\end{equation}
This is represented by the vector
\[
	\begin{bmatrix} 5/3 & -1 & -1/3 & 0 & -1/3 & 0\end{bmatrix}.
\]
Since this left-hand side is zero, I can add any scalar multiple of this equation to any of the equations for $x_i$ and still have an equation for $x_i$.
For example, the equation for $x_5$ is
\[
	x_5 = 7 - 4x_1 - 3x_2.
\]
Thus, I can add $-4$ times \eqref{eq:zero-equation} to this equation without changing the left-hand side:
\[ x_5 = 7 - 4x_1 - 3x_2 = 7 - 4x_1 - 3x_2 + -4\left(\frac{5}{3} - x_1 - \frac{1}{3}x_2 - \frac{1}{3}x_4\right) = \frac{1}{3} - \frac{5}{3}x_2 + \frac{4}{3} x_4.
\]
Notice that we end up with an equation that does not include $x_1$ and now has $x_4$, just like we wanted.
In fact, this works in all of our equations, including those for the objective function and even for $x_1$!
Since the coefficient of $x_1$ in \eqref{eq:zero-equation} is -1, when we scale it by the coefficient of $x_1$ in any particular row, the $x_1$ cancels out.
If we want to do this in a single operation, we use the outer product.
We set our new tableau to
\[
	T = T + \begin{bmatrix}3 \\ 1 \\ 0 \\ -1 \\ -3 \\ -4\end{bmatrix}\begin{bmatrix} 5/3 & -1 & -1/3 & 0 & -1/3 & 0\end{bmatrix}.
\]
The column vector is just the second column of $T$, which is the column containing the coefficients of $x_1$ in each row.
When we compute this sum, we obtain the tableau.
\[
	T = \begin{bmatrix}
		5 &  0 & 1 & 0 & -1 & 0 \\
		5/3 & 0 &-1/3 & 0 &-1/3 & 0 \\
		0 & 0 & 1 & 0 & 0 & 0 \\
		1/3 & 0 & 4/3 & 0 & 1/3 & 0 \\
		0 & 0 & 0 & 0 & 1 & 0 \\
		1/3 & 0 & -5/3 & 0 & 4/3 & 0
	\end{bmatrix}.
\]

You can check that these are all the correct pivots.
Most importantly, $x_2$ and $x_4$ are now our nonbasic variables.

\section*{Auxiliary Problems}

When one of the entries of $b$ is negative, we need to run an auxiliary problem to find a feasible point.
Try adding $x_0$ as the last variable.
That way you just need to add a single row and column to your current tableau $T$.
You can check that subtracting $x_0$ from each of the constraints is the same as adding $x_0$ to each of the expressions for the slack variables.
Since we also need write $x_0$ in terms of itself ($x_0 = x_0$), this is equivalent to setting the last column equal to 1 for all the rows corresponding to slack variables, plus one new row.
We also need to change the objective function to $-x_0$.
Let's let $N$ be the matrix for the auxiliary problem.
Then we can construct it from $T$ using the code 
\begin{lstlisting}
>>> N = zeros((s+1,s+1))
>>> N[0:s,0:s] = T
>>> N[n:s+1,s] = 1
>>> N[0,s] = -1
\end{lstlisting}

Before you run simplex on this auxiliary tableau, make sure you do a pivot on the last column and the row corresponding to the smallest entry of $b$.
Check that the objective function value is 0 when simplex finishes running.
If not, your initial problem is infeasible.
If the problem is feasible, get the system of equations from $N$ and put them back into $T$, leaving off the last row and column of $N$ (for $x_0$) and the first row (corresponding to the objective function).
\begin{lstlisting}
T[1:s,0:s] = N[1:s,0:s]
\end{lstlisting}
The last thing you need to do is insert your previous objective function.
However, you need to re-write it in terms of the current nonbasic variables.
Fortunately, $T$ currently contains all of your variables written in terms of the nonbasic variables.
You can check (mathematically, or however you want to satisfy yourself) that
\begin{lstlisting}
T[0,0:s] = T[0,0:s]*T
\end{lstlisting}
will put the objective function into the first row, now written in terms of the new nonbasic variables.

\section*{Getting Return Values}

When you reach a stopping point (all the coefficients in the objective function are nonpositive), all you have to do to get the return values is to set $x = T[0,1:n+1]$, since these contain the current values of each $x_i$ and set $\mathtt{fval} = T[0,0]$.
This is of course assuming you didn't have any error situations (infeasibility or unboundedness), which you should handle separately.

