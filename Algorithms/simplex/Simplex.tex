\lab{Algorithms}{Simplex Method}{Simplex Method}
\objective{Implement the Simplex Algorithm to solve constrained linear optimization problems.}
\label{lab:Simplex}

The Simplex Algorithm numbers among the most important algorithms invented in the last 100 years.
It provides a straightforward method for finding optimal solutions to constrained linear optimization problems.
The algorithm obtains the solution by traversing the edges of the feasible region defined by the constraints.
The theory of convex optimization guarantees that the optimal point will be found among the vertices of the feasible
region, and so a carefully implemented Simplex Algorithm will discover the exact solution in a finite number of steps.

\section{Standard Form}
The Simplex Algorithm accepts a constrained linear optimization problem in standard form,
as given below:
\begin{align*}
\text{maximize}\qquad &c^Tx \\
\text{subject to}\qquad A&x \leq b \\
 &x \geq 0
\end{align*}
Note that any constrained linear optimization problem can be converted to standard form, so there is no loss of 
generality in restricting our attention to this particular formulation.

Such an optimization problem defines a region in space called the \emph{feasible region}, the set of points
satisfying the constraints. Because the constraints are all linear, the feasible region forms a geometric object 
called a \emph{polytope}, having flat faces and edges.
The Simplex Algorithm jumps among the vertices of the feasible region searching for an optimal point.
It does this by moving along the edges of the feasible region in such a way that the objective function is always increased.

Implementing the Simplex Algorithm is straightforward, provided one carefully follows the procedure. 
We will break the algorithm into several small steps, and write a function to perform each one.
To become familiar with the execution of the Simplex algorithm, it is helpful to work several examples by hand.

\section*{The Simplex Solver}
Our program will be more lengthy than many other lab exercises and will consist of a collection of functions working 
together to produce a final result.
It is important to clearly define the task of each function and how all the functions will work together.
If this program is written haphazardly, it will be much longer and harder to read than it needs to be.
We will walk you through the steps of implementing the Simplex Algorithm as a Python class.
Since the Simplex Algorithm assumes that all the variables are non-negative, we do not need any special logic for it.
%what is this previous statement saying? What 'special logic' would you need if the variables were negative?

For demonstration purposes, we will use the following linear program.
\begin{align*}
\text{maximize}\qquad & 3x_0 + 2x_1 \\
\text{subject to}\qquad
& x_0 - x_1 \leq 2 \\
& 3x_0 + x_1 \leq 5 \\
& 4x_0 + 3x_1 \leq 7 \\
& x_0, x_1 \geq 0.
\end{align*}

\subsection{Accepting a Linear Program}
Our first task is to determine if we can even use the Simplex algorithm.
Assuming that the problem is presented to us in standard form, we need
to check that the feasible region is nonempty.

\begin{problem}
Write a Python class that accepts a constrained linear optimization problem and check its feasibility.
You may implement the feasibility check directly into the class initialization method, or use a separate class method.
To simplify the implementation of your solver, we only check feasibility at the origin.
If the linear program is unfeasible at the origin (that is, if $A0 \not\leq b$), alert the user that Simplex might not 
work as expected.
Your class might have the following structure, where the problem is accepted in the initialization method.
\begin{lstlisting}
class SimplexSolver(object):
    def __init__(self, c, A, b):
        if infeasible:
            print "Problem is infeasible"
\end{lstlisting}
\label{prob:initsolver}
\end{problem}

\subsection{Adding Slack Variables}
Our next step is to convert the inequality constraints $Ax \leq b$ into equality constraints
by introducing slack variables $z$, so that our constraints take the form $Ax + z = b$.
If the constraint matrix $A$ is an $m \times n$ matrix, then there are $m$ slack variables.
When adding slack variables, it is useful represent all of your variables in a convenient way.
One effective way is to refer to a variable by its subscript.
For example, we can use the integers $0$ through $n-1$ to refer to the original (non-slack) variables $x_0$ through
$x_{n-1}$, and we can use the integers $n$ through $n+m-1$ to track the slack variables (where the slack variable
corresponding to the $i$-th row of the constraint matrix is represented by the index $n+i-1$).

We also need some way to track which variables are basic and which variables are nonbasic.
A useful representation for the variables is a Python list, where the elements of the list are integers.
Since we know how many basic variables we have ($m$, to be precise), we can partition the list so that all the basic 
variables are kept in the first $m$ locations, and all the non-basic variables are stored at the end of the list.
Note that initially, the basic variables are simply the slack variables.
As the Simplex Algorithm progresses, however, the basic variables change, and it will be necessary to swap two
elements of our list. This can be done in a single, efficient line of Python code:
\begin{lstlisting}
>>> L = [0, 1, 2, 3, 4]
>>> L[1], L[3] = L[3], L[1]
\end{lstlisting}

\begin{problem}
Design and implement a way to store and track all of the basic and non-basic variables.

\emph{Hint: Using integers that represent the index of each variable is useful for Problem \ref{prob:blands}.}
\label{prob:slackvars}
\end{problem}

\subsection{Creating a Tableau}
After we have determined that our program is feasible, we need to create the initial tableau.
You may structure the tableau to suit your specific implementation.
Remember that your tableau will need to include in some way the slack variables that you created in Problem \ref{prob:slackvars}.

There are many different ways to build your tableau.
One way is to mimic the tableau that is often used when performing the Simplex Algorithm by hand.
Define
\[
\bar{A} = \begin{bmatrix}
  A & I_m
\end{bmatrix},
\]
where $I_m$ is the $m \times m$ identity matrix,
and define
\[
\bar{c} = \begin{bmatrix}
  c\\
  0\\
  \vdots\\
  0
\end{bmatrix}.
\]
That is, $\bar{c} \in \mathbb{R}^{n+m}$ such that the first $n$ entries are $c$ and the final $m$ entries are zeros.
Then the initial tableau has the form
\begin{equation}
T = \begin{bmatrix}
    0 & -\bar{c}^T & 1  \\
    b & \bar{A} & 0
    \end{bmatrix}.
\label{eqn:hand_tab}
\end{equation}
For our example problem, the initial tableau is
\begin{equation*}
T = \begin{bmatrix}
    0 & -3 & -2 & 0 & 0 & 0 & 1\\
    2 & 1 & -1 & 1 & 0 & 0 & 0\\
    5 & 3 & 1 & 0 & 1 & 0 & 0\\
    7 & 4 & 3 & 0 & 0 & 1 & 0
    \end{bmatrix}.
\end{equation*}

The advantage of using this kind of tableau is that it is easy to check the progress of your Algorithm by hand.
The disadvantage is that pivot operations require careful bookkeeping to track the variables and constraints.

We can also use a tableau of the following format:
\begin{equation}
T = \begin{bmatrix}
    0 & c^T  & 0 \\
    0 & I_n & 0\\
    b & -A  & 0
\end{bmatrix}.
\label{eqn:matrix_tab}
\end{equation}
Here, $T$ is a square matrix of size $(n+m+1) \times (n+m+1)$.
The advantage of this form of tableau is all the pivot bookkeeping is built into the matrix.
For our example problem, the initial tableau of this form is
\begin{equation*}
T = \begin{bmatrix}
        0 & 3 & 2 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 & 0 \\
        2 &-1 & 1 & 0 & 0 & 0 \\
        5 &-3 &-1 & 0 & 0 & 0 \\
        7 &-4 &-3 & 0 & 0 & 0
\end{bmatrix}.
\end{equation*}

\begin{problem}
Add a method to your Simplex solver that will create the initial tableau that you will use.
Using a NumPy array to represent your tableau will simplify several parts of the Simplex algorithm.
Your class may have the following structure at this point:
\begin{lstlisting}
class SimplexSolver(object):
    def __init__(self, c, A, b):
        if infeasible:
            print "LP is infeasible"

        self.makeTableau()

    def makeTableau(self):
        pass
\end{lstlisting}
\label{prob:maketableau}
\end{problem}

\subsection{Pivoting}
Pivoting is the mechanism that really makes Simplex useful.
Pivoting refers to the act of swapping basic and nonbasic variables.
Depending on how you store your variables, you may need to modify a few different parts of your solver to reflect this swapping.

When initiating a pivot, you need to determine which variables will be swapped.
In the tableau representation, you find a specific element on which to pivot, and the row and column that contain the pivot 
element give the variables that need to be swapped.
Gaussian elimination is then performed on the tableau so that the pivot column becomes an elementary vector.

We need to use some care when choosing a pivot element. To find the pivot column, search from left to right along the top row of the tableau 
(ignoring the first column) and stop once you encounter the first negative value. T
If we are using the tableau representation in equation \ref{eqn:matrix_tab}, pivot operations are reduced to a simple matrix equation:
\[T = T + T_m \otimes T_n,\]
where $T_m$ is the column corresponding to the variable entering the basis and $T_n$ is a normalized vector corresponding to the variable leaving the basis.  The result of the equation is the new tableau.


\begin{problem}
Write a method that will determine the pivot row and pivot column according to Bland's Rule.
\begin{definition}[Bland's Rule]
Choose the nonbasic variable with the smallest index that has a positive coefficient in the objective function
as the leaving variable.  Choose the basic variable with the smallest index among all the binding basic variables.
\end{definition}

Bland's Rule is important in avoiding cycles when performing pivots.
This rule guarantees that a feasible Simplex problem will terminate in a finite number of pivots.
\label{prob:blands}
\end{problem}

\begin{problem}
Add methods that your Simplex solver that will perform a single pivot operation from start to completion.
You pivoting method should check for unboundedness.
If during pivoting, the system becomes unbounded, return an exception to the user.
\end{problem}

\subsection{Reading the Tableau}
When your solver has reached a maximal point, it would be nice if the user doesn't have to extract the maximal solution from the tableau.

\begin{problem}
Write an additional method in your solver that will return the maximal solution in the format: \li{(max value, basic variables, nonbasic variables)}, where the basic and nonbasic variables are represented as two dictionaries that map the subscript of the variable to its corresponding value.
For example, the tuple \li{(55.0, \{0: .5, 3: .33333\}, \{1: 0, 2: 0\})} represents the solution to the system
where maximal value of the objective function is $55.0$ and the
basic variables are $x_0=.5$ and $x_3=.33333$ and the nonbasic variables are $x_1, x_2$ which are both zero.
The correct format of this tuple is critical as this tuple of information will be used judge if your solver works!
\end{problem}






%-------------------------------------------------------
where $c \in \mathbb{R}^n$ is a column vector, $b \in \mathbb{R}^m$ is a row vector, and $A \in \mathbb{R}^{m \times n}$.
The output $x$ is the optimal point and the optimal value is {\tt fval}.
The output {\tt exit} is one of the following values:
\begin{itemize}
\item 1: Successful execution--you found a solution.
\item 2: The problem is infeasible.
\item 3: The problem is unbounded.
\end{itemize}
If either of the two error events occur, you should return \li{None} for the values of \li{x} and \li{fval}.

You are free to implement {\tt linprog} any way you see fit, provided it satisfies the above requirements (you cannot just call an existing lp solver however, and you must use the Simplex method!).

\section*{Tableau Representation}

The first problem you need to address is how to represent the tableau.
We're going to use an approach that might be a little confusing at first but greatly simplifies the pivot operations.
We recommend creating an $m + n + 1$ square NumPy matrix, where $m$ is the number of constraints and $n$ is the number of decision variables.
The first row represents the objective function and the first column is for the constants.
The remaining columns are the coefficients of the variables.
The remaining rows express the value of the variables in terms of a constant and the nonbasic variables.
To illustrate this approach, let's consider the following example problem:

\begin{align*}
	\mbox{maximize}\qquad
        &    3x_1 + 2x_2 \\
	\mbox{subject to}\qquad
        &     x_1 - x_2 \leq 2 \\
		&	 3x_1 + x_2 \leq 5 \\
		&	 4x_1 + 3x_2 \leq 7 \\
		&     x_1, x_2 \geq 0.
\end{align*}

There is no need to distinguish the slack variables from the decision variables, so we will call our slack variables $x_3, x_4,$ and $x_5$.
Then our problem becomes
\begin{align*}
	\mbox{maximize}\qquad
        &    3x_1 + 2x_2 \\
	\mbox{subject to}\qquad
        &     x_1 - x_2 + x_3 = 2 \\
		&	 3x_1 + x_2 + x_4 = 5 \\
		&	 4x_1 + 3x_2 + x_5 = 7 \\
		&     x_1, x_2, x_3, x_4, x_5 \geq 0.
\end{align*}

We initialize simplex by making the decision variables $x_1, x_2$ nonbasic and the slack variables basic (assuming the origin is feasible, but we will deal with initially infeasible problems shortly).
The objective function is already written in terms of the nonbasic variables: $\zeta = 0 + 3x_1 + 2x_2$.
We want to write all the variables in terms of the nonbasic variables. This information we get from the constraints:
\[ x_3 = 2 - x_1 + x_2, \qquad x_4 = 5 - 3x_1 - x_2, \qquad x_5 = 7 - 4x_1 - 3x_2. \]
For consistency, and simplicity that will be demonstrated later on, we want to express ALL the variables in terms of the nonbasic variables, not just the basic variables, so we add the expressions
\[ x_1 = x_1, \qquad x_2 = x_2 \]
to the tableau.
This may seem silly, but it makes pivot operations very simple, as we will see.
In matrix form, we then have the following initial tableau.

\[
	T = \begin{bmatrix}
		0 & 3 & 2 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 & 0 & 0 \\
		0 & 0 & 1 & 0 & 0 & 0 \\
		2 &-1 & 1 & 0 & 0 & 0 \\
		5 &-3 &-1 & 0 & 0 & 0 \\
		7 &-4 &-3 & 0 & 0 & 0
	\end{bmatrix}.
\]
The first row is the objective function written as a constant plus a linear combination of the nonbasic variables.
The remaining rows are all the variables written as a constant plus a linear combination of the nonbasic variables.
The general form of the $T$ matrix is
\[ T = \begin{bmatrix}
    0 & c^T   & 0 \\
    0 & I_n & 0 \\
    b & -A  & 0
\end{bmatrix}, \]
where $I_n$ is an $n \times n$ identity matrix.
Therefore, your {\tt createtableau} function might include code like the following

\begin{lstlisting}
>>> m,n = A.shape
>>> s = m + n + 1;    % number of variables + number of constraints + 1
>>> T = numpy.zeros((s,s))
>>> T[0, 1:n+1] = c.T
>>> T[s-n-1:s, 0] = b.squeeze()
...
\end{lstlisting}

Note that you need the squeeze function, built into numpy, to remove single-dimensional entries from the shape of a numpy array.

\section*{Pivot Operations}

One of the nice features of the proposed tableau representation is the simplicity of pivot operations.
In our example problem, the first pivot should occur with $x_1$ leaving and $x_4$ entering.
In other words, we want to pivot at row $i = 4$ and column $j = 1$ in the tableau (the indices are offset by one because of the objective function and the row of constants).
The row corresponding to $x_4$ is
\[
\begin{bmatrix} 5 &-3 &-1 & 0 & 0 & 0\end{bmatrix}.
\]
This represents the equation
\[
	x_4 = 5 - 3x_1 - x_2.
\]
Our eventual goal is to solve for $x_1$ and substitute into the remaining rows of the tableau.
A simple method to accomplish this is to rewrite the equation so that we have zero on the left-hand side:
\[
	0 = 5 - 3x_1 - x_2 - x_4.
\]
Now, we can normalize this equation so that the coefficient of $x_1$ is -1.
This is always accomplished by dividing the equation by the negative of the coefficient of $x_1$:
\begin{equation}\label{eq:zero-equation}
	0 = \frac{5}{3} - x_1 - \frac{1}{3}x_2 - \frac{1}{3}x_4.
\end{equation}
This is represented by the vector
\[
	\begin{bmatrix} 5/3 & -1 & -1/3 & 0 & -1/3 & 0\end{bmatrix}.
\]
Since this left-hand side is zero, I can add any scalar multiple of this equation to any of the equations for $x_i$ and still have an equation for $x_i$.
For example, the equation for $x_5$ is
\[
	x_5 = 7 - 4x_1 - 3x_2.
\]
Thus, I can add $-4$ times \eqref{eq:zero-equation} to this equation without changing the left-hand side:
\[ x_5 = 7 - 4x_1 - 3x_2 = 7 - 4x_1 - 3x_2 + -4\left(\frac{5}{3} - x_1 - \frac{1}{3}x_2 - \frac{1}{3}x_4\right) = \frac{1}{3} - \frac{5}{3}x_2 + \frac{4}{3} x_4.
\]
Notice that we end up with an equation that does not include $x_1$ and now has $x_4$, just like we wanted.
In fact, this works in all of our equations, including those for the objective function and even for $x_1$!
Since the coefficient of $x_1$ in \eqref{eq:zero-equation} is -1, when we scale it by the coefficient of $x_1$ in any particular row, the $x_1$ cancels out.
If we want to do this in a single operation, we use the outer product.
We set our new tableau to
\[
	T = T + \begin{bmatrix}3 \\ 1 \\ 0 \\ -1 \\ -3 \\ -4\end{bmatrix}\begin{bmatrix} 5/3 & -1 & -1/3 & 0 & -1/3 & 0\end{bmatrix}.
\]
The column vector is just the second column of $T$, which is the column containing the coefficients of $x_1$ in each row.
When we compute this sum, we obtain the tableau.
\[
	T = \begin{bmatrix}
		5 &  0 & 1 & 0 & -1 & 0 \\
		5/3 & 0 &-1/3 & 0 &-1/3 & 0 \\
		0 & 0 & 1 & 0 & 0 & 0 \\
		1/3 & 0 & 4/3 & 0 & 1/3 & 0 \\
		0 & 0 & 0 & 0 & 1 & 0 \\
		1/3 & 0 & -5/3 & 0 & 4/3 & 0
	\end{bmatrix}.
\]

You can check that these are all the correct pivots.
Most importantly, $x_2$ and $x_4$ are now our nonbasic variables.

\section*{Auxiliary Problems}

When one of the entries of $b$ is negative, we need to run an auxiliary problem to find a feasible point.
Try adding $x_0$ as the last variable.
That way you just need to add a single row and column to your current tableau $T$.
You can check that subtracting $x_0$ from each of the constraints is the same as adding $x_0$ to each of the expressions for the slack variables.
Since we also need write $x_0$ in terms of itself ($x_0 = x_0$), this is equivalent to setting the last column equal to 1 for all the rows corresponding to slack variables, plus one new row.
We also need to change the objective function to $-x_0$.
Let's let $N$ be the matrix for the auxiliary problem.
Then we can construct it from $T$ using the code
\begin{lstlisting}
>>> N = zeros((s+1,s+1))
>>> N[0:s,0:s] = T
>>> N[n:s+1,s] = 1
>>> N[0,s] = -1
\end{lstlisting}

Before you run simplex on this auxiliary tableau, make sure you do a pivot on the last column and the row corresponding to the smallest entry of $b$.
Check that the objective function value is 0 when simplex finishes running.
If not, your initial problem is infeasible.
If the problem is feasible, get the system of equations from $N$ and put them back into $T$, leaving off the last row and column of $N$ (for $x_0$) and the first row (corresponding to the objective function).
\begin{lstlisting}
T[1:s,0:s] = N[1:s,0:s]
\end{lstlisting}
The last thing you need to do is insert your previous objective function.
However, you need to re-write it in terms of the current nonbasic variables.
Fortunately, $T$ currently contains all of your variables written in terms of the nonbasic variables.
You can check (mathematically, or however you want to satisfy yourself) that
\begin{lstlisting}
T[0,0:s] = T[0,0:s]*T
\end{lstlisting}
will put the objective function into the first row, now written in terms of the new nonbasic variables.

\section*{Getting Return Values}

When you reach a stopping point (all the coefficients in the objective function are nonpositive), all you have to do to get the return values is to set $x = T[0,1:n+1]$, since these contain the current values of each $x_i$ and set $\mathtt{fval} = T[0,0]$.
This is of course assuming you didn't have any error situations (infeasibility or unboundedness), which you should handle separately.

