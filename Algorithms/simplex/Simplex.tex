\lab{Algorithms}{Simplex Method}{Simplex Method}
\objective{Implement the Simplex Algorithm to solve constrained linear optimization problems.}
\label{lab:Simplex}

The Simplex Algorithm numbers among the most important algorithms invented in the last 100 years.
It provides a straightforward method for finding optimal solutions to constrained linear optimization problems.
The algorithm obtains the solution by traversing the edges of the feasible region defined by the constraints.
The theory of convex optimization guarantees that the optimal point will be found among the vertices of the feasible
region, and so a carefully implemented Simplex Algorithm will discover the exact solution in a finite number of steps.

\section{Standard Form}
The Simplex Algorithm accepts a constrained linear optimization problem in standard form,
as given below:

\begin{align*}
\text{maximize}\qquad &c^Tx \\
\text{subject to}\qquad A&x \leq b \\
 &x \geq 0
\end{align*}
Note that any constrained linear optimization problem can be converted to standard form, so there is no loss of
generality in restricting our attention to this particular formulation.

Such an optimization problem defines a region in space called the \emph{feasible region}, the set of points
satisfying the constraints. Because the constraints are all linear, the feasible region forms a geometric object
called a \emph{polytope}, having flat faces and edges.
The Simplex Algorithm jumps among the vertices of the feasible region searching for an optimal point.
It does this by moving along the edges of the feasible region in such a way that the objective function is always increased.

Implementing the Simplex Algorithm is straightforward, provided one carefully follows the procedure.
We will break the algorithm into several small steps, and write a function to perform each one.
To become familiar with the execution of the Simplex algorithm, it is helpful to work several examples by hand.

\section*{The Simplex Solver}
Our program will be more lengthy than many other lab exercises and will consist of a collection of functions working
together to produce a final result.
It is important to clearly define the task of each function and how all the functions will work together.
If this program is written haphazardly, it will be much longer and harder to read than it needs to be.
We will walk you through the steps of implementing the Simplex Algorithm as a Python class.
Since the Simplex Algorithm assumes that all the variables are non-negative, we do not need any special logic for it.
%what is this previous statement saying? What 'special logic' would you need if the variables were negative?

For demonstration purposes, we will use the following linear program.
\begin{align*}
\text{maximize}\qquad & 3x_0 + 2x_1 \\
\text{subject to}\qquad
& x_0 - x_1 \leq 2 \\
& 3x_0 + x_1 \leq 5 \\
& 4x_0 + 3x_1 \leq 7 \\
& x_0, x_1 \geq 0.
\end{align*}

\subsection{Accepting a Linear Program}
Our first task is to determine if we can even use the Simplex algorithm.
Assuming that the problem is presented to us in standard form, we need
to check that the feasible region is nonempty.

\begin{problem}
Write a Python class that accepts a constrained linear optimization problem and check its feasibility.
You may implement the feasibility check directly into the class initialization method, or use a separate class method.
To simplify the implementation of your solver, we only check feasibility at the origin.
Return an error if the given program is infeasible at the origin.
Your class might have the following structure, where the linear program is accepted in the initialization method.
\begin{lstlisting}
class SimplexSolver(object):
    def __init__(self, c, A, b):
        if infeasible:
            print "Problem is infeasible"
\end{lstlisting}
\label{prob:initsolver}
\end{problem}

\subsection{Adding Slack Variables}
Our next step is to convert the inequality constraints $Ax \leq b$ into equality constraints
by introducing slack variables $z$, so that our constraints take the form $Ax + z = b$.
If the constraint matrix $A$ is an $m \times n$ matrix, then there are $m$ slack variables.
When adding slack variables, it is useful represent all of your variables in a convenient way.
One effective way is to refer to a variable by its subscript.
For example, we can use the integers $0$ through $n-1$ to refer to the original (non-slack) variables $x_0$ through
$x_{n-1}$, and we can use the integers $n$ through $n+m-1$ to track the slack variables (where the slack variable
corresponding to the $i$-th row of the constraint matrix is represented by the index $n+i-1$).

We also need some way to track which variables are basic and which variables are nonbasic.
A useful representation for the variables is a Python list, where the elements of the list are integers.
Since we know how many basic variables we have ($m$, to be precise), we can partition the list so that all the basic
variables are kept in the first $m$ locations, and all the non-basic variables are stored at the end of the list.
Note that initially, the basic variables are simply the slack variables.
As the Simplex Algorithm progresses, however, the basic variables change, and it will be necessary to swap two
elements of our list. This can be done in a single, efficient line of Python code:
\begin{lstlisting}
>>> L = [0, 1, 2, 3, 4]
>>> L[1], L[3] = L[3], L[1]
\end{lstlisting}

\begin{problem}
Design and implement a way to store and track all of the basic and non-basic variables.

\emph{Hint: Using integers that represent the index of each variable is useful for Problem \ref{prob:blands}.}
\label{prob:slackvars}
\end{problem}

\subsection{Creating a Tableau}
After we have determined that our program is feasible, we need to create the initial tableau.
You may structure the tableau to suit your specific implementation.
Remember that your tableau will need to include in some way the slack variables that you created in Problem \ref{prob:slackvars}.

There are many different ways to build your tableau.
One way is to mimic the tableau that is often used when performing the Simplex Algorithm by hand.
Define
\[
\bar{A} = \begin{bmatrix}
  A & I_m
\end{bmatrix},
\]
where $I_m$ is the $m \times m$ identity matrix,
and define
\[
\bar{c} = \begin{bmatrix}
  c\\
  0\\
  \vdots\\
  0
\end{bmatrix}.
\]
That is, $\bar{c} \in \mathbb{R}^{n+m}$ such that the first $n$ entries are $c$ and the final $m$ entries are zeros.
Then the initial tableau has the form
\begin{equation}
T = \begin{bmatrix}
    0 & -\bar{c}^T & 1  \\
    b & \bar{A} & 0
    \end{bmatrix}.
\label{eqn:hand_tab}
\end{equation}
For our example problem, the initial tableau is
\begin{equation*}
T = \begin{bmatrix}
    0 & -3 & -2 & 0 & 0 & 0 & 1\\
    2 & 1 & -1 & 1 & 0 & 0 & 0\\
    5 & 3 & 1 & 0 & 1 & 0 & 0\\
    7 & 4 & 3 & 0 & 0 & 1 & 0
    \end{bmatrix}.
\end{equation*}

The advantage of using this kind of tableau is that it is easy to check the progress of your Algorithm by hand.
The disadvantage is that pivot operations require careful bookkeeping to track the variables and constraints.

We can also use a tableau of the following format:
\begin{equation}
T = \begin{bmatrix}
    0 & c^T  & 0 \\
    0 & I_n & 0\\
    b & -A  & 0
\end{bmatrix}.
\label{eqn:matrix_tab}
\end{equation}
Here, $T$ is a square matrix of size $(n+m+1) \times (n+m+1)$.
The advantage of this form of tableau is all the pivot bookkeeping is built into the matrix.
For our example problem, the initial tableau of this form is
\begin{equation}
T = \begin{bmatrix}
        0 & 3 & 2 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 & 0 \\
        2 &-1 & 1 & 0 & 0 & 0 \\
        5 &-3 &-1 & 0 & 0 & 0 \\
        7 &-4 &-3 & 0 & 0 & 0
\end{bmatrix}.
\label{eqn:matrix_inittab}
\end{equation}

\begin{problem}
Add a method to your Simplex solver that will create the initial tableau that you will use.
Using a NumPy array to represent your tableau will simplify several parts of the Simplex algorithm.
Your class may have the following structure at this point:
\begin{lstlisting}
class SimplexSolver(object):
    def __init__(self, c, A, b):
        if infeasible:
            print "LP is infeasible"

        self.makeTableau()

    def makeTableau(self):
        pass
\end{lstlisting}
\label{prob:maketableau}
\end{problem}

\subsection{Pivoting}
Pivoting is the mechanism that really makes Simplex useful.
Pivoting refers to the act of swapping basic and nonbasic variables.
Depending on how you store your variables, you may need to modify a few different parts of your solver to reflect this swapping.

When initiating a pivot, you need to determine which variables will be swapped.
In the tableau representation, you find a specific element on which to pivot, and the row and column that contain the pivot
element give the variables that need to be swapped.
Gaussian elimination is then performed on the tableau so that the pivot column becomes an elementary vector.

We need to use some care when choosing a pivot element. To find the pivot column, search from left to right along the top row of the tableau
(ignoring the first column) and stop once you encounter the first negative value. T
If we are using the tableau representation in equation \ref{eqn:matrix_tab}, pivot operations are reduced to a simple matrix equation:
\[T = T + T_m \otimes T_n,\]
where $T_m$ is the column corresponding to the variable entering the basis and $T_n$ is a normalized vector corresponding to the variable leaving the basis.  The result of the equation is the new tableau.

For example, for the initial tableau, \ref{eqn:matrix_inittab}, we will demonstrate the first pivot operation.
We can do the entire pivot with a single outer product.
the first pivot should occur with $x_1$ leaving and $x_4$ entering.
In other words, we want to pivot at row $i = 4$ and column $j = 1$ in the tableau (the indices are offset by one because of the objective function and the row of constraints).

The row corresponding to $x_4$ is
\[
\begin{bmatrix} 5 &-3 &-1 & 0 & 0 & 0\end{bmatrix}.
\]
This represents the equation
\[
x_4 = 5 - 3x_1 - x_2.
\]
Our eventual goal is to solve for $x_1$ and substitute into the remaining rows of the tableau.
A simple method to accomplish this is to rewrite the equation so that we have zero on the left-hand side:
\[
0 = 5 - 3x_1 - x_2 - x_4.
\]
Now, we can normalize this equation so that the coefficient of $x_1$ is $-1$.
This is always accomplished by dividing the equation by the negative of the coefficient of $x_1$:
\begin{equation}
0 = \frac{5}{3} - x_1 - \frac{1}{3}x_2 - \frac{1}{3}x_4.
\label{eq:zero-equation}
\end{equation}
This is represented by the vector
\[
\begin{bmatrix} 5/3 & -1 & -1/3 & 0 & -1/3 & 0\end{bmatrix}.
\]
Since this left-hand side is zero, I can add any scalar multiple of this equation to any of the equations for $x_i$ and still have an equation for $x_i$.
For example, the equation for $x_5$ is
\[
x_5 = 7 - 4x_1 - 3x_2.
\]
Thus, I can add $-4$ times \eqref{eq:zero-equation} to this equation without changing the left-hand side:
\[ x_5 = 7 - 4x_1 - 3x_2 = 7 - 4x_1 - 3x_2 + -4\left(\frac{5}{3} - x_1 - \frac{1}{3}x_2 - \frac{1}{3}x_4\right) = \frac{1}{3} - \frac{5}{3}x_2 + \frac{4}{3} x_4.
\]
Notice that we end up with an equation that does not include $x_1$ and now has $x_4$, just like we wanted.
In fact, this works in all of our equations, including those for the objective function and even for $x_1$!
Since the coefficient of $x_1$ in \eqref{eq:zero-equation} is $-1$, when we scale it by the coefficient of $x_1$ in any particular row, the $x_1$ cancels out.
\[
T = T + \begin{bmatrix}3 \\ 1 \\ 0 \\ -1 \\ -3 \\ -4\end{bmatrix}\begin{bmatrix} 5/3 & -1 & -1/3 & 0 & -1/3 & 0\end{bmatrix}.
\]
The column vector is just the second column of $T$, which is the column containing the coefficients of $x_1$ in each row.
When we compute this sum, we obtain the tableau.
\[
T = \begin{bmatrix}
        5 &  0 & 1 & 0 & -1 & 0 \\
        5/3 & 0 &-1/3 & 0 &-1/3 & 0 \\
        0 & 0 & 1 & 0 & 0 & 0 \\
        1/3 & 0 & 4/3 & 0 & 1/3 & 0 \\
        0 & 0 & 0 & 0 & 1 & 0 \\
        1/3 & 0 & -5/3 & 0 & 4/3 & 0
\end{bmatrix}.
\]

\begin{problem}
Write a method that will determine the pivot row and pivot column according to Bland's Rule.
\begin{definition}[Bland's Rule]
Choose the nonbasic variable with the smallest index that has a positive coefficient in the objective function
as the leaving variable.  Choose the basic variable with the smallest index among all the binding basic variables.
\end{definition}

Bland's Rule is important in avoiding cycles when performing pivots.
This rule guarantees that a feasible Simplex problem will terminate in a finite number of pivots.
\label{prob:blands}
\end{problem}

\begin{problem}
Add methods that your Simplex solver that will perform a single pivot operation from start to completion.
You pivoting method should check for unboundedness.
If during pivoting, the system becomes unbounded, return an exception to the user.
\end{problem}

\subsection{Reading the Tableau}
When your solver has reached a maximal point, it would be nice if the user doesn't have to extract the maximal solution from the tableau.

\begin{problem}
Write an additional method in your solver that will return the maximal solution in the format: \li{(max value, basic variables, nonbasic variables)}, where the basic and nonbasic variables are represented as two dictionaries that map the subscript of the variable to its corresponding value.
For example, the tuple \li{(55.0, \{0: .5, 3: .33333\}, \{1: 0, 2: 0\})} represents the solution to the system
where maximal value of the objective function is $55.0$ and the
basic variables are $x_0=.5$ and $x_3=.33333$ and the nonbasic variables are $x_1, x_2$ which are both zero.
The correct format of this tuple is critical as this tuple of information will be used judge if your solver works!
\end{problem}


%---------------------------------------------------------------------------------------------------
%
%
% \section*{Auxiliary Problems}
%
% When one of the entries of $b$ is negative, we need to run an auxiliary problem to find a feasible point.
% Try adding $x_0$ as the last variable.
% That way you just need to add a single row and column to your current tableau $T$.
% You can check that subtracting $x_0$ from each of the constraints is the same as adding $x_0$ to each of the expressions for the slack variables.
% Since we also need write $x_0$ in terms of itself ($x_0 = x_0$), this is equivalent to setting the last column equal to 1 for all the rows corresponding to slack variables, plus one new row.
% We also need to change the objective function to $-x_0$.
% Let's let $N$ be the matrix for the auxiliary problem.
% Then we can construct it from $T$ using the code
% \begin{lstlisting}
% >>> N = zeros((s+1,s+1))
% >>> N[0:s,0:s] = T
% >>> N[n:s+1,s] = 1
% >>> N[0,s] = -1
% \end{lstlisting}
%
% Before you run simplex on this auxiliary tableau, make sure you do a pivot on the last column and the row corresponding to the smallest entry of $b$.
% Check that the objective function value is 0 when simplex finishes running.
% If not, your initial problem is infeasible.
% If the problem is feasible, get the system of equations from $N$ and put them back into $T$, leaving off the last row and column of $N$ (for $x_0$) and the first row (corresponding to the objective function).
% \begin{lstlisting}
% T[1:s,0:s] = N[1:s,0:s]
% \end{lstlisting}
% The last thing you need to do is insert your previous objective function.
% However, you need to re-write it in terms of the current nonbasic variables.
% Fortunately, $T$ currently contains all of your variables written in terms of the nonbasic variables.
% You can check (mathematically, or however you want to satisfy yourself) that
% \begin{lstlisting}
% T[0,0:s] = T[0,0:s]*T
% \end{lstlisting}
% will put the objective function into the first row, now written in terms of the new nonbasic variables.
