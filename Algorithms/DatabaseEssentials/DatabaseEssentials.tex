\newcommand{\lsql}[1]{\lstinline[language=SQL,prebreak=]!#1!}

\lab{Algorithms}{SQL and Relational Databases}{SQL}
\objective{Understand concepts of a relational database and the fundamentals of the SQL language via SQLite.}
\label{lab:sql_rdb}

When working with large amounts of data, it is important to be able to quickly find and retrieve interesting information.
Fortunately, there is a way to handle such massive amounts of data in a reasonably efficient way.
A database allows us to store and retrieve data very quickly.
These databases are managed by a \emph{database management system}, or DBMS.
The DBMS is software that allows users to interact directly with the database.

\section*{Relational Databases}
A \emph{relational} database is paradigm for organizing data inside of a database.
This paradigm assumes that all data can be represented as a tuple of information.
A table, or \emph{relation}, is simply a set of tuples.
Each table has a \emph{schema} that defines the attributes of a tuple.
In the relational paradigm, there must be at least one column that can act as a primary key.
This can uniquely identify each tuple, or row, of the table.
It is common to use an ID number or other such unique information for the primary key.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{rdb_table.pdf}
\caption{Elements of a relation.}
\label{fig:relation}
\end{figure}

One important feature of databases are transactions.
Most relational databases are transactional databases.
The best way to conceptualize this is imagine that your database is like a bank.
Your connection the database is analogous to the bank teller.
When you make a deposit, or series of deposits, you are making a transaction.
This transaction should have certain properties.
These properties are succinctly captured in the acronym of ACID.
ACID compliance is an important feature transactional databases.
It describes the properties that a good database should have: atomic, consistent, isolation, and durable.
\begin{description}
\item[Atomic.] Each transaction should be all or nothing.  If some error occurs in the middle of a transaction, no changes are made to the database.  Changes are only made during error-free transactions.  This is especially useful if a transaction is interrupted due to power failure, or other type of unforeseen error.
\item[Consistent.] Ensure that the database is always left in a valid state.  This ensures that any transaction satisfies all rules and constraints of the database.
\item[Isolation.] The final effect of concurrent transactions it equivalent to the final effect of each transaction in serial.  This essentially means that if we run perform several transactions in parallel, none of the transactions can depend on each other.
\item[Durable.] Once a transaction is committed, the changes are permanent regardless of any errors that may happen later.
\end{description}

\section*{Introduction to SQL}
Most common DBMSs use a variant of the SQL language to interact with the database.
SQL is an acronym for \emph{Structured Query Language}.
While in general, SQL is not portable across databases, we will focus on the parts of SQL that are relatively common.
SQL consists of blocks of code called statements.
Each statement is made up of clauses which may or may not require predicates.
Predicates specify conditions that can limit the effect of a clause.

Let's look at an example SQL statement
\begin{lstlisting}[language=SQL]
SELECT * FROM table WHERE id=3+1 AND name='Bob';
\end{lstlisting}
This statement includes a SELECT clause and a WHERE clause.
The WHERE clause contains two predicates: \texttt{id=3+1} and \texttt{name='Bob'}
These two predicates limit the effect of the SELECT clause because any resulting tuples in the table must satisfy both conditions.
This entire statement is classified as a query since it does not modify the database at all.

SQL has several classes of statements.
The two main classes we will cover in this lab are schema (Table \ref{table:sql-schema}) and data manipulation (Table \ref{table:sql-data_manip}).
We will give you a simplified description of each command and its syntax.
You are encouraged to look up the full syntax outside of this lab.
 
\begin{table}
\begin{tabular}{|l|l|}
\hline
Keyword & Syntax \\
\hline
\lsql{CREATE TABLE} & \lsql{CREATE TABLE <table> (<col1> <type>, <col2> <type>, ...);} \\
\lsql{DROP TABLE} & \lsql{DROP TABLE <table>;} \\
\lsql{ALTER TABLE} & \lsql{ALTER TABLE <table> [ADD/DROP] <col>} \\
\lsql{CREATE INDEX} & \lsql{CREATE INDEX <name> ON <table> (<col>)} \\
\lsql{DROP INDEX} & \lsql{DROP INDEX <name>} \\
\hline
\end{tabular}
\caption{The SQL Schema commands}
\label{table:sql-schema}
\end{table}

\begin{table}
\begin{tabular}{|l|l|}
\hline
Keyword & Syntax \\
\hline
\lsql{INSERT INTO} & \lsql{INSERT INTO <table> <attributes> VALUES (<value1>, <value2>, ...)} \\
\lsql{UPDATE} & \lsql{UPDATE <table> SET (<col1>=<val1>, <col2>=<val2>, ...) WHERE <condition>} \\
\lsql{DELETE} & \lsql{DELETE FROM <table> WHERE <condition>} \\
\lsql{SELECT} & \lsql{SELECT <attributes> FROM <table> WHERE <condition>} \\
\hline
\end{tabular}
\caption{The SQL Data Manipulation commands}
\label{table:sql-data_manip}
\end{table}

\section*{SQL in Python}
Python has built-in support for SQLite databases using the standard library.
Let's open a database called \texttt{test1}.
\begin{lstlisting}
import sqlite3 as sql
db = sql.connect("test1")
\end{lstlisting}
The \li{connect()} function is used to connect to a database.
If it does not already exist, then a new database will be created using string passed as the argument.
The new database was created as a file in the current working directory.
If we wanted an in-memory database, we would call \li{sql.connect(``:memory:'')}.

To execute SQL commands, we need to get a cursor object from the database.
\begin{lstlisting}
cur = db.cursor()
\end{lstlisting}

The cursor object has several useful methods (Table \ref{table:cursormethods}).
\begin{table}
\begin{tabular}{|l|l|}
\hline
Method & Description \\
\hline
\li{execute} & Execute a single SQL statement \\
\li{executemany} & Execute a single SQL statement over a sequence \\
\li{executescript} & Execute a SQL script (multiple SQL commands) \\
\li{close} & Closes the cursor object \\
\hline
\end{tabular}
\caption{Cursor object methods}
\label{table:cursormethods}
\end{table}

Before creating a table, we need to  understand how SQLite stores information in a database.  SQLite uses four native data types (a simplified system from other SQL database managers).  Table \ref{table:typemap}, gives a mapping between Python and SQLite native types.
\begin{table}
\begin{tabular}{|l|l|}
\hline
Python Type & SQLite Type \\
\hline
\li{None} & \lsql{NULL} \\
\li{int} & \lsql{INTEGER} \\
\li{long} & \lsql{INTEGER} \\
\li{float} & \lsql{REAL} \\
\li{str} & \lsql{TEXT} \\
\li{buffer} & \lsql{BLOB} \\
\hline
\end{tabular}
\caption{Python and SQLite types mapping}
\label{table:typemap}
\end{table}

Let's create a table.
\begin{lstlisting}
result = cur.execute('CREATE TABLE student_information (StudentID INTEGER NOT NULL, Name TEXT, SSN INTEGER, MajorCode INTEGER);')
\end{lstlisting}
This will create the empty table in Table \ref{table:student_information}.
\begin{table}
\begin{tabular}{|l|l|l|l|}
\hline
StudentID & Name & SSN & MajorCode \\
\hline
\end{tabular}
\caption{student\_information}
\label{table:student_information}
\end{table}

The arguments in parentheses are the column names followed by the data type that entries in that column will be.  The \lsql{INTEGER} data type in SQLite is a 1, 2, 3, 4, 6, or 8 byte integer depending on the value.  The \lsql{NOT NULL} command is a \emph{constraint} on the StudentID column.  It requires that all records in the table have a student ID.

Note that each command that we execute returns a another cursor object.  We can use the fetch objects to look at any results of the previous command.  The result is formally known as the \emph{result set}.  If you use \li{result.fetchall()}, you will see an empty list.  That is because the create table command does not return a result set.

Now we want to build a relation between students and the courses they've had and their grades in those courses.
\begin{lstlisting}
cur.execute('CREATE TABLE student_classes (StudentID INT NOT NULL, CourseID INT, Grade TEXT);')
\end{lstlisting}

\begin{problem}
In this problem you will create two new tables.  The first table will be called MajorInfo and have a columns called MajorCode and MajorName.  MajorCode is an integer and MajorName is a string.

The second table will be called CourseInfo and have columns called CourseID and CourseName, also integers and strings, respectively.
\label{prob:new_tables}
\end{problem}



\subsection*{Inserting Data}
In this section we will insert data into the tables that we have created.  First we will show how to manually add data using the {\tt INSERT} command.  {\tt INSERT} requires that we specify which table that we wish to modify and the values for each column.  For example

\begin{lstlisting}
mysql> INSERT INTO student_information VALUES(55, "John Smith", 372897382, 2);
Query OK, 1 row affected (0.20 sec)
\end{lstlisting}

We may also remove the line we just inserted using the {\tt DELETE} command.

\begin{lstlisting}

mysql> DELETE FROM student_information WHERE StudentID=55;
Query OK, 1 row affected (0.16 sec)

\end{lstlisting}

These commands are useful for table maintenance or where it may be automated, but MySQL is a very powerful tool for dealing with large amounts of data.  Manually inserting and deleting in such a table is ornerous in even simple cases and essentially impossible for a moderately sized table.  If we have some data in a file on our computer, we may use the {\tt LOAD} command to automatically move it into our database.

\begin{lstlisting}

mysql> LOAD DATA LOCAL INFILE "./students.dat" INTO TABLE student_information FIELDS TERMINATED BY ",";
Query OK, 10 rows affected (0.07 sec)

\end{lstlisting}

{\tt LOCAL INFILE} specifies that we are a loading file from a location on our local machine.  We then specify the path to the file and which table to load the data into.  Finally, we specify what character separates the columns.  Even for large files this operation moves very fast.

\begin{problem}

Download students.dat, class\_info.dat, classes.dat, and major\_info.dat and use the {\tt LOAD} command to insert the data in each into student\_information, ClassInfo, student\_classes and MajorInfo respectively.

\end{problem}

\begin{problem}

Using python, write a program that will accepts a number of rows and returns a 10 column matrix with the specified number of rows and write it to a file with each column separated by commas.  The first column should be in ascending numeric order, but the others should have random numbers in them.  Generate matrices with 100, 1000, 10000, and 100000 rows.  Load each into a different table in a new database and time the load operation.  How does the time increase?

\end{problem}

\section{Querying and Joining Tables}

Now that we have loaded data in the form of our student database we will learn to query and join the tables.  The first command that we will use is {\tt SELECT}, which returns specified rows of a table.  For example

\begin{lstlisting}
mysql> SELECT Name FROM student_information;
+---------------------+
| Name                |
+---------------------+
|  Jared Webb         |
|  Alexander Zaitzeff |
|  Rachel Suggs       |
|  Jeff Humphreys     |
|  Abe Frandsen       |
|  Tyler Jarvis       |
|  Jessica Purcell    |
|  Janice Joplin      |
|  John Lennon        |
|  Tupac Shakur       |
+---------------------+
10 rows in set (0.00 sec)
\end{lstlisting}

After {\tt SELECT} we specify a column and a table to query, and MySQL returns the requested rows.  We may also add conditions to our command to get more refined results.

\begin{lstlisting}

mysql> SELECT Name FROM student_information WHERE StudentID = 4;
+-----------------+
| Name            |
+-----------------+
|  Jeff Humphreys |
+-----------------+
1 row in set (0.00 sec)

\end{lstlisting}

Or we may select more than one column

\begin{lstlisting}

mysql> SELECT Name, SocSecurity FROM student_information WHERE StudentID = 4;
+-----------------+-------------+
| Name            | SocSecurity |
+-----------------+-------------+
|  Jeff Humphreys |   736452198 |
+-----------------+-------------+
1 row in set (0.00 sec)

mysql> SELECT * FROM student_information WHERE StudentID = 4;
+-----------+-----------------+-------------+-----------+
| StudentID | Name            | SocSecurity | MajorCode |
+-----------+-----------------+-------------+-----------+
|         4 |  Jeff Humphreys |   736452198 |         3 |
+-----------+-----------------+-------------+-----------+
1 row in set (0.00 sec)

mysql> SELECT * FROM student_information;
+-----------+---------------------+-------------+-----------+
| StudentID | Name                | SocSecurity | MajorCode |
+-----------+---------------------+-------------+-----------+
|         1 |  Jared Webb         |   123456789 |         1 |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |
|         3 |  Rachel Suggs       |   431256789 |         2 |
|         4 |  Jeff Humphreys     |   736452198 |         3 |
|         5 |  Abe Frandsen       |   172645382 |         4 |
|         6 |  Tyler Jarvis       |   174382645 |         3 |
|         7 |  Jessica Purcell    |   827635142 |         2 |
|         8 |  Janice Joplic      |   987263512 |         1 |
|         9 |  John Lennon        |   192837641 |         3 |
|        10 |  Tupac Shakur       |   192837412 |         2 |
+-----------+---------------------+-------------+-----------+
10 rows in set (0.00 sec)

\end{lstlisting}

We may join tables by columns using the {\tt INNER JOIN} command.  This is a very powerful tool for uniting data across many tables.  In MySQL we can use {\tt INNER JOIN} in conjunction with {\tt SELECT} to query data across many tables into place.  For example we can inner join student\_classes and student\_information on the StudentID column to display student information and grades in one table.

\begin{lstlisting}

mysql> SELECT * FROM student_information INNER JOIN student_classes ON student_information.StudentID = student_classes.StudentID;
+-----------+---------------------+-------------+-----------+-----------+---------+-------+
| StudentID | Name                | SocSecurity | MajorCode | StudentID | ClassID | Grade |
+-----------+---------------------+-------------+-----------+-----------+---------+-------+
|         1 |  Jared Webb         |   123456789 |         1 |         1 |       4 |  C    |
|         1 |  Jared Webb         |   123456789 |         1 |         1 |       3 |  B    |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |         2 |       4 |  A    |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |         2 |       3 |  A    |
|         3 |  Rachel Suggs       |   431256789 |         2 |         3 |       2 |  C    |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |         2 |       1 |  B    |
|         4 |  Jeff Humphreys     |   736452198 |         3 |         4 |       1 |  A    |
|         5 |  Abe Frandsen       |   172645382 |         4 |         5 |       2 |  C    |
|         5 |  Abe Frandsen       |   172645382 |         4 |         5 |       3 |  C    |
|         6 |  Tyler Jarvis       |   174382645 |         3 |         6 |       4 |  D    |
|         6 |  Tyler Jarvis       |   174382645 |         3 |         6 |       2 |  A    |
|         6 |  Tyler Jarvis       |   174382645 |         3 |         6 |       1 |  B    |
|         7 |  Jessica Purcell    |   827635142 |         2 |         7 |       2 |  A    |
|         7 |  Jessica Purcell    |   827635142 |         2 |         7 |       1 |  C    |
|         8 |  Janice Joplic      |   987263512 |         1 |         8 |       2 |  D    |
|         8 |  Janice Joplic      |   987263512 |         1 |         8 |       1 |  A    |
|         5 |  Abe Frandsen       |   172645382 |         4 |         5 |       4 |  A    |
|         9 |  John Lennon        |   192837641 |         3 |         9 |       2 |  B    |
|         9 |  John Lennon        |   192837641 |         3 |         9 |       3 |  C    |
|        10 |  Tupac Shakur       |   192837412 |         2 |        10 |       1 |  A    |
|        10 |  Tupac Shakur       |   192837412 |         2 |        10 |       2 |  A    |
+-----------+---------------------+-------------+-----------+-----------+---------+-------+
21 rows in set (0.05 sec)

\end{lstlisting}

By specify columns, we can display the grades of one student.

\begin{lstlisting}

mysql> SELECT Name, Grade FROM student_information INNER JOIN student_classes ON student_information.StudentID = student_classes.StudentID WHERE student_information.StudentID=6;
+---------------+-------+
| Name          | Grade |
+---------------+-------+
|  Tyler Jarvis |  D    |
|  Tyler Jarvis |  A    |
|  Tyler Jarvis |  B    |
+---------------+-------+
3 rows in set (0.05 sec)

\end{lstlisting}

\begin{problem}

Use {\tt INNER JOIN} and {\tt SELECT} to display the student\_information table, but show the students majors and classes instead of ClassID and MajorID.

\end{problem}

\let\undefined\lsql