\newcommand{\lsql}[1]{\lstinline[language=SQL,prebreak=]!#1!}

\lab{Algorithms}{SQL and Relational Databases}{SQL}
\objective{Understand concepts of a relational database and the fundamentals of the SQL language via SQLite.}
\label{lab:sql_rdb}

When working with large amounts of data, it is important to be able to quickly find and retrieve interesting information.
Fortunately, there is a way to handle such massive amounts of data in a reasonably efficient way.
A database allows us to store and retrieve data very quickly.
These databases are managed by a \emph{database management system}, or DBMS.
The DBMS is software that allows users to interact directly with the database.

\section*{Relational Databases}
A \emph{relational} database is paradigm for organizing data inside of a database.
This paradigm assumes that all data can be represented as a tuple of information.
A table, or \emph{relation}, is simply a set of tuples.
Each table has a \emph{schema} that defines the attributes of a tuple.
In the relational paradigm, there must be at least one column that can act as a primary key.
This can uniquely identify each tuple, or row, of the table.
It is common to use an ID number or other such unique information for the primary key.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{rdb_table.pdf}
\caption{Elements of a relation.}
\label{fig:relation}
\end{figure}

One important feature of databases are transactions.
Most relational databases are transactional databases.
The best way to conceptualize this is imagine that your database is like a bank.
Your connection the database is analogous to the bank teller.
When you make a deposit, or series of deposits, you are making a transaction.
This transaction should have certain properties.
These properties are succinctly captured in the acronym of ACID.
ACID compliance is an important feature transactional databases.
It describes the properties that a good database should have: atomic, consistent, isolation, and durable.
\begin{description}
\item[Atomic.] Each transaction should be all or nothing.  If some error occurs in the middle of a transaction, no changes are made to the database.  Changes are only made during error-free transactions.  This is especially useful if a transaction is interrupted due to power failure, or other type of unforeseen error.
\item[Consistent.] Ensure that the database is always left in a valid state.  This ensures that any transaction satisfies all rules and constraints of the database.
\item[Isolation.] The final effect of concurrent transactions it equivalent to the final effect of each transaction in serial.  This essentially means that if we run perform several transactions in parallel, none of the transactions can depend on each other.
\item[Durable.] Once a transaction is committed, the changes are permanent regardless of any errors that may happen later.
\end{description}

\section*{Introduction to SQL}
Most common DBMSs use a variant of the SQL language to interact with the database.
SQL is an acronym for \emph{Structured Query Language}.
While in general, SQL is not portable across databases, we will focus on the parts of SQL that are relatively common.
SQL consists of blocks of code called statements.
Each statement is made up of clauses which may or may not require predicates.
Predicates specify conditions that can limit the effect of a clause.

\begin{info}
SQL commands are often written in all caps to help distinguish them from the other parts of the query.
It is only a matter of style.
SQLite, along with most other database managers, are case insensitive.
\end{info}

Let's look at an example SQL statement
\begin{lstlisting}[language=SQL]
SELECT * FROM table WHERE id=3+1 AND name='Bob';
\end{lstlisting}
This statement includes a SELECT clause and a WHERE clause.
The WHERE clause contains two predicates: \texttt{id=3+1} and \texttt{name='Bob'}
These two predicates limit the effect of the SELECT clause because any resulting tuples in the table must satisfy both conditions.
This entire statement is classified as a query since it does not modify the database at all.

SQL has several classes of statements.
The two main classes we will cover in this lab are schema (Table \ref{table:sql-schema}) and data manipulation (Table \ref{table:sql-data_manip}).
We will give you a simplified description of each command and its syntax.
You are encouraged to look up the full syntax outside of this lab.
 
\begin{table}
\begin{tabular}{|l|l|}
\hline
Keyword & Syntax \\
\hline
\lsql{CREATE TABLE} & \lsql{CREATE TABLE <table> (<col1> <type>, <col2> <type>, ...);} \\
\lsql{DROP TABLE} & \lsql{DROP TABLE <table>;} \\
\lsql{CREATE INDEX} & \lsql{CREATE INDEX <name> ON <table> (<col>)} \\
\lsql{DROP INDEX} & \lsql{DROP INDEX <name>} \\
\hline
\end{tabular}
\caption{The SQL Schema commands}
\label{table:sql-schema}
\end{table}

\begin{table}
\begin{tabular}{|l|l|}
\hline
Keyword & Syntax \\
\hline
\lsql{INSERT INTO} & \lsql{INSERT INTO <table> <attributes> VALUES (<value1>, <value2>, ...)} \\
\lsql{UPDATE} & \lsql{UPDATE <table> SET (<col1>=<val1>, <col2>=<val2>, ...) WHERE <condition>} \\
\lsql{DELETE} & \lsql{DELETE FROM <table> WHERE <condition>} \\
\lsql{SELECT} & \lsql{SELECT <attributes> FROM <table> WHERE <condition>} \\
\hline
\end{tabular}
\caption{The SQL Data Manipulation commands}
\label{table:sql-data_manip}
\end{table}

\section*{SQL in Python}
Python has built-in support for SQLite databases using the standard library.
Let's open a database called \texttt{test1}.
\begin{lstlisting}
import sqlite3 as sql
db = sql.connect("test1")
\end{lstlisting}
The \li{connect()} function is used to connect to a database.
If it does not already exist, then a new database will be created using string passed as the argument.
The new database was created as a file in the current working directory.
If we wanted an in-memory database, we would call \li{sql.connect(``:memory:'')}.

To execute SQL commands, we need to get a cursor object from the database.
\begin{lstlisting}
cur = db.cursor()
\end{lstlisting}

The cursor object has several useful methods (Table \ref{table:cursormethods}).
\begin{table}
\begin{tabular}{|l|l|}
\hline
Method & Description \\
\hline
\li{execute} & Execute a single SQL statement \\
\li{executemany} & Execute a single SQL statement over a sequence \\
\li{executescript} & Execute a SQL script (multiple SQL commands) \\
\li{close} & Closes the cursor object \\
\hline
\end{tabular}
\caption{Cursor object methods}
\label{table:cursormethods}
\end{table}

Before creating a table, we need to  understand how SQLite stores information in a database.  SQLite uses four native data types (a simplified system from other SQL database managers).  Table \ref{table:typemap}, gives a mapping between Python and SQLite native types.
\begin{table}
\begin{tabular}{|l|l|}
\hline
Python Type & SQLite Type \\
\hline
\li{None} & \lsql{NULL} \\
\li{int} & \lsql{INTEGER} \\
\li{long} & \lsql{INTEGER} \\
\li{float} & \lsql{REAL} \\
\li{str} & \lsql{TEXT} \\
\li{buffer} & \lsql{BLOB} \\
\hline
\end{tabular}
\caption{Python and SQLite types mapping}
\label{table:typemap}
\end{table}

\subsection*{Creating and Dropping Tables}
Let's create a table.
\begin{lstlisting}
result = cur.execute('CREATE TABLE student_information (StudentID INTEGER NOT NULL, Name TEXT, SSN INTEGER, MajorCode INTEGER);')
\end{lstlisting}
This will create the empty table in Table \ref{table:student_information}.
\begin{table}
\begin{tabular}{|l|l|l|l|}
\hline
StudentID & Name & SSN & MajorCode \\
\hline
\end{tabular}
\caption{student\_information}
\label{table:student_information}
\end{table}

The arguments in parentheses are the column names followed by the data type that entries in that column will be.  The \lsql{INTEGER} data type in SQLite is a 1, 2, 3, 4, 6, or 8 byte integer depending on the value.  The \lsql{NOT NULL} command is a \emph{constraint} on the StudentID column.  It requires that all records in the table have a student ID.

\begin{info}
SQLite does not enforce types on columns.
Just like Python, SQLite is dynamically typed.
However, most other database systems strictly enforce column types.
It is a good idea to conform to the column types.
\end{info}


Note that each command that we execute returns a another cursor object.  We can use the fetch objects to look at any results of the previous command.  The result is formally known as the \emph{result set}.  If you use \li{result.fetchall()}, you will see an empty list.  That is because the create table command does not return a result set.

Now we want to build a relation between students and the courses they've had and their grades in those courses.
\begin{lstlisting}
cur.execute('CREATE TABLE student_classes (StudentID INT NOT NULL, CourseID INT, Grade TEXT);')
\end{lstlisting}

\begin{problem}
In this problem you will create two new tables.  The first table will be called MajorInfo and have a columns called MajorCode and MajorName.  MajorCode is an integer and MajorName is a string.

The second table will be called CourseInfo and have columns called CourseID and CourseName, also integers and strings, respectively.
\label{prob:new_tables}
\end{problem}

We can also destroy tables using the \lsql{DROP TABLE} command.
\begin{lstlisting}
cur.execute("CREATE TABLE test_table (id int, name text);")
\end{lstlisting}
We can delete the table by dropping it.
\begin{lstlisting}
\cur.execute("DROP TABLE test_table;")
\end{lstlisting}
If a table doesn't exist, an exception will be raised.
We can tell the database to drop the table only if it really exists by using \lsql{DROP TABLE IF EXISTS test_table;}.

\subsection*{Inserting and Removing Data}
Let's insert some data into our new tables.
We can add rows to tables using the \lsql{INSERT INTO} command.
\begin{lstlisting}
cur.execute("INSERT INTO student_information VALUES(55, 'John Smith', 372897382, 2);")
\end{lstlisting}
After running this statement, we will have the table in Table \ref{table:student_information1}.
\begin{table}
\begin{tabular}{|l|l|l|l|}
\hline
StudentID & Name & SSN & MajorCode \\
\hline
55 & John Smith & 372897382 & 2 \\
\hline
\end{tabular}
\caption{student\_information}
\label{table:student_information1}
\end{table}

Note that SQLite will assume that values match sequentially with the schema of the table.
We can also specify the schema of the table to use in the mapping of the values.
\begin{lstlisting}
cur.execute("INSERT INTO student_information(MajorCode, Name, SSN, StudentID)  VALUES(55, 'John Smith', 372897382, 2);")
\end{lstlisting}
This will map the value 55 to MajorCode and the value 2 to StudentID.  This can be useful sometimes.

We may remove rows from a table using the \lsql{DELETE FROM} command.
\begin{lstlisting}
cur.execute("DELETE FROM student_information WHERE MajorCode=55;")
\end{lstlisting}

\begin{warn}
\emph{\textbf{Never}} use Python's string operations to construct a SQL query.
It is extremely insecure and is an easy target for a well known type of database called a SQL injection attack.

Parameter substitution can be used to construct dynamic queries.
In the simplest way, it involves using a `?' character whenever you want to use a value and providing a sequence of values as a second argument to \li{execute()}.
\begin{lstlisting}
statment = "INSERT INTO student_information VALUES(?, ?, ?, ?);"
values = (55, 'John Smith', 372897382, 2)
cur.execute(statement, values)
\end{lstlisting}
\end{warn}

\begin{problem}
The ICD is a large collection of codes used to classify any diagnosis that a doctor would make.
When someone goes to the hospital or doctors office, their visit will be recorded using these codes.
Insurance companies, the government, and researchers find this data useful.
The data file provided to you has simulated health histories for one million persons.
Each line has columns for identification number, gender, age followed by ICD-9 codes of various quantities.
Create a new database with a single table to store all the simulated data.

Because of the volume of data, it is highly recommended the \li{executemany()} method of the cursor.
It will be about twice as fast as using an \li{execute()} for each line of the CSV file.
\label{prob:icd9tables}
\end{problem}

\begin{problem}
Create the following tables in the same database you created in Problem \ref{prob:icd9tables}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
StudentID & Name & MajorCode \\
\hline
401767594 & Michelle Fernandez & 1 \\
678665086 & Gilbert Chapman & 1 \\
553725811 & Roberta Cook & 2 \\
886308195 & Rene Cross & 3 \\
103066521 & Cameron Kim & 4 \\
821568627 & Mercedes Hall & 3 \\
206208438 & Kristopher Tran & 2 \\
341324754 & Cassandra Holland & 1 \\
262019426 & Alfonso Phelps & 3 \\
622665098 & Sammy Burke &2 \\
\hline
\end{tabular}
\caption{students}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|}
\hline
ID & Major \\
\hline
1 & Math \\
2 & Science \\
3 & Writing \\
4 & Art \\
\hline
\end{tabular}
\caption{majors}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
StudentID & ClassID & Grade \\
\hline
401767594 & 4 & C \\
401767594 & 3 & B- \\
678665086 & 4 & A+ \\
678665086 & 3 & A+ \\
553725811 & 2 & C \\
678665086 & 1 & B \\
886308195 & 1 & A \\
103066521 & 2 & C \\
103066521 & 3 & C- \\
821568627 & 4 & D \\
821568627 & 2 & A+ \\
821568627 & 1 & B \\
206208438 & 2 & A \\
206208438 & 1 & C+ \\
341324754 & 2 & D- \\
341324754 & 1 & A- \\
103066521 & 4 & A \\
262019426 & 2 & B \\
262019426 & 3 & C \\
6226650980 & 1 & A \\
622665098 & 2 & A- \\
\hline
\end{tabular}
\caption{grades}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|}
\hline
ClassID & Name \\
\hline
1 & Calculus \\
2 & English \\
3 & Pottery \\
4 & History \\
\hline
\end{tabular}
\caption{classes}
\end{table}

\end{problem}


\subsection*{Selecting Data From Tables}
We can select

%-----------------------------------------------------------
\section{Querying and Joining Tables}
Now that we have loaded data in the form of our student database we will learn to query and join the tables.  The first command that we will use is {\tt SELECT}, which returns specified rows of a table.  For example

\begin{lstlisting}
mysql> SELECT Name FROM student_information;
+---------------------+
| Name                |
+---------------------+
|  Jared Webb         |
|  Alexander Zaitzeff |
|  Rachel Suggs       |
|  Jeff Humphreys     |
|  Abe Frandsen       |
|  Tyler Jarvis       |
|  Jessica Purcell    |
|  Janice Joplin      |
|  John Lennon        |
|  Tupac Shakur       |
+---------------------+
10 rows in set (0.00 sec)
\end{lstlisting}

After {\tt SELECT} we specify a column and a table to query, and MySQL returns the requested rows.  We may also add conditions to our command to get more refined results.

\begin{lstlisting}

mysql> SELECT Name FROM student_information WHERE StudentID = 4;
+-----------------+
| Name            |
+-----------------+
|  Jeff Humphreys |
+-----------------+
1 row in set (0.00 sec)

\end{lstlisting}

Or we may select more than one column

\begin{lstlisting}

mysql> SELECT Name, SocSecurity FROM student_information WHERE StudentID = 4;
+-----------------+-------------+
| Name            | SocSecurity |
+-----------------+-------------+
|  Jeff Humphreys |   736452198 |
+-----------------+-------------+
1 row in set (0.00 sec)

mysql> SELECT * FROM student_information WHERE StudentID = 4;
+-----------+-----------------+-------------+-----------+
| StudentID | Name            | SocSecurity | MajorCode |
+-----------+-----------------+-------------+-----------+
|         4 |  Jeff Humphreys |   736452198 |         3 |
+-----------+-----------------+-------------+-----------+
1 row in set (0.00 sec)

mysql> SELECT * FROM student_information;
+-----------+---------------------+-------------+-----------+
| StudentID | Name                | SocSecurity | MajorCode |
+-----------+---------------------+-------------+-----------+
|         1 |  Jared Webb         |   123456789 |         1 |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |
|         3 |  Rachel Suggs       |   431256789 |         2 |
|         4 |  Jeff Humphreys     |   736452198 |         3 |
|         5 |  Abe Frandsen       |   172645382 |         4 |
|         6 |  Tyler Jarvis       |   174382645 |         3 |
|         7 |  Jessica Purcell    |   827635142 |         2 |
|         8 |  Janice Joplic      |   987263512 |         1 |
|         9 |  John Lennon        |   192837641 |         3 |
|        10 |  Tupac Shakur       |   192837412 |         2 |
+-----------+---------------------+-------------+-----------+
10 rows in set (0.00 sec)

\end{lstlisting}

We may join tables by columns using the {\tt INNER JOIN} command.  This is a very powerful tool for uniting data across many tables.  In MySQL we can use {\tt INNER JOIN} in conjunction with {\tt SELECT} to query data across many tables into place.  For example we can inner join student\_classes and student\_information on the StudentID column to display student information and grades in one table.

\begin{lstlisting}

mysql> SELECT * FROM student_information INNER JOIN student_classes ON student_information.StudentID = student_classes.StudentID;
+-----------+---------------------+-------------+-----------+-----------+---------+-------+
| StudentID | Name                | SocSecurity | MajorCode | StudentID | ClassID | Grade |
+-----------+---------------------+-------------+-----------+-----------+---------+-------+
|         1 |  Jared Webb         |   123456789 |         1 |         1 |       4 |  C    |
|         1 |  Jared Webb         |   123456789 |         1 |         1 |       3 |  B    |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |         2 |       4 |  A    |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |         2 |       3 |  A    |
|         3 |  Rachel Suggs       |   431256789 |         2 |         3 |       2 |  C    |
|         2 |  Alexander Zaitzeff |   987654321 |         1 |         2 |       1 |  B    |
|         4 |  Jeff Humphreys     |   736452198 |         3 |         4 |       1 |  A    |
|         5 |  Abe Frandsen       |   172645382 |         4 |         5 |       2 |  C    |
|         5 |  Abe Frandsen       |   172645382 |         4 |         5 |       3 |  C    |
|         6 |  Tyler Jarvis       |   174382645 |         3 |         6 |       4 |  D    |
|         6 |  Tyler Jarvis       |   174382645 |         3 |         6 |       2 |  A    |
|         6 |  Tyler Jarvis       |   174382645 |         3 |         6 |       1 |  B    |
|         7 |  Jessica Purcell    |   827635142 |         2 |         7 |       2 |  A    |
|         7 |  Jessica Purcell    |   827635142 |         2 |         7 |       1 |  C    |
|         8 |  Janice Joplic      |   987263512 |         1 |         8 |       2 |  D    |
|         8 |  Janice Joplic      |   987263512 |         1 |         8 |       1 |  A    |
|         5 |  Abe Frandsen       |   172645382 |         4 |         5 |       4 |  A    |
|         9 |  John Lennon        |   192837641 |         3 |         9 |       2 |  B    |
|         9 |  John Lennon        |   192837641 |         3 |         9 |       3 |  C    |
|        10 |  Tupac Shakur       |   192837412 |         2 |        10 |       1 |  A    |
|        10 |  Tupac Shakur       |   192837412 |         2 |        10 |       2 |  A    |
+-----------+---------------------+-------------+-----------+-----------+---------+-------+
21 rows in set (0.05 sec)

\end{lstlisting}

By specify columns, we can display the grades of one student.

\begin{lstlisting}

mysql> SELECT Name, Grade FROM student_information INNER JOIN student_classes ON student_information.StudentID = student_classes.StudentID WHERE student_information.StudentID=6;
+---------------+-------+
| Name          | Grade |
+---------------+-------+
|  Tyler Jarvis |  D    |
|  Tyler Jarvis |  A    |
|  Tyler Jarvis |  B    |
+---------------+-------+
3 rows in set (0.05 sec)

\end{lstlisting}

\begin{problem}

Use {\tt INNER JOIN} and {\tt SELECT} to display the student\_information table, but show the students majors and classes instead of ClassID and MajorID.

\end{problem}

\let\undefined\lsql